package cromwell.engine.finalcall

import cromwell.core.OptionNotFoundException
import cromwell.engine.FullyQualifiedName
import cromwell.engine.backend.{BackendCallJobDescriptor, WorkflowDescriptor}
import cromwell.engine.workflow.BackendCallKey
import cromwell.webservice.WorkflowMetadataResponse
import wdl4s.{FullyQualifiedName => _, _}

import scala.collection.immutable.Traversable
import scala.util.{Failure, Success}

/**
  * Create a Call and return Inputs for a special Call to be run after all others in the Workflow.
  *
  * Each instance of FinalCall is used to create a separate Call per Workflow via FinalCall.createCall.
  *
  * After the workflow completes, the Call is provided CallInputs generated by createCallInputs.
  */
trait FinalCall {
  /**
    * Part of the call name. To ensure this final call name doesn't conflict with workflow tasks/calls, the full call
    * name will be created with FinalCall.callName().
    */
  def finalCallName: String

  /** The source for the task to turn into a Call. */
  def wdlSource: WdlSource

  /**
    * Creates the call inputs for this final call based on the workflow(descriptor) and the metadata produced by the
    * workflow.
    */
  def createCallInputs(workflow: WorkflowDescriptor, metadata: WorkflowMetadataResponse): CallInputs
}

object FinalCall {
  private val FinalCallPrefix = "$final_call"

  private val finalCalls: Traversable[FinalCall] = List(CopyWorkflowLogCall, CopyWorkflowOutputsCall, CopyCallLogsCall)

  def createFinalCalls(workflowDescriptor: WorkflowDescriptor): Traversable[Call] = {
    finalCalls map createCall(workflowDescriptor)
  }

  /** Return the name for a Call based on a final call name. */
  private def callName(finalCallname: String): String = "%s$%s".format(FinalCall.FinalCallPrefix, finalCallname)

  private def createCall(workflowDescriptor: WorkflowDescriptor)(finalCall: FinalCall): Call = {
    // Callers are each passing in WorkflowDescriptor, but we only need the Workflow.
    val workflow = workflowDescriptor.namespace.workflow
    val wdlAst = AstTools.getAst(finalCall.wdlSource, finalCall.finalCallName)
    val importNamespace = callName("final_calls")
    val wdlNamespace = WdlNamespace.apply(wdlAst, finalCall.wdlSource, null, Option(importNamespace))
    val task = wdlNamespace.tasks.headOption.getOrElse(
      throw new IllegalStateException(s"Did not generate a task from wdl: ${finalCall.wdlSource}"))
    // This is handled as a special case by the WorkflowActor. We don't have to list the specially here.
    val prerequisiteCallNames = Set.empty[String]
    val call = Call(None, callName(finalCall.finalCallName), task, prerequisiteCallNames, Map.empty, Option(workflow))
    call
  }

  /** Retrieve a value from the workflow options. */
  def getWorkflowOption(workflowDescriptor: WorkflowDescriptor, key: String): Option[String] = {
    workflowDescriptor.workflowOptions.get(key) match {
      case Success(value) => Option(value)
      case Failure(e: OptionNotFoundException) => None
      case Failure(e: IllegalArgumentException) =>
        workflowDescriptor.workflowLogger.warn(s"$key expected to be of type String", e)
        None
      case Failure(e) =>
        workflowDescriptor.workflowLogger.warn(s"Error looking up $key from workflow options: ${e.getMessage}", e)
        None
    }
  }

  /** Return the final call with this fqn. */
  private def finalCallForFqn(fqn: FullyQualifiedName) = {
    finalCalls.
      find(finalCall => fqn.endsWith(callName(finalCall.finalCallName))).
      getOrElse(throw new IllegalArgumentException(s"$fqn is not a final call"))
  }

  implicit class FinalCallKey(val key: BackendCallKey) extends AnyVal {
    /** Does this FQN conform to a final call? */
    def isFinalCall = FinalCallString(key.scope.fullyQualifiedName).isFinalCall

    /** Return a job descriptor for this final call. */
    def finalCallJobDescriptor(workflow: WorkflowDescriptor, metadata: WorkflowMetadataResponse) = {
      val finalCall = finalCallForFqn(key.scope.fullyQualifiedName)
      val callInputs = finalCall.createCallInputs(workflow, metadata)
      BackendCallJobDescriptor(workflow, key, callInputs, None)
    }
  }

  implicit class FinalCallString(val fqn: FullyQualifiedName) extends AnyVal {
    /** Does this FQN conform to a final call? */
    def isFinalCall = fqn contains FinalCallPrefix

    /** Create a store key for this workflow(descriptor). */
    def storeKey(workflowDescriptor: WorkflowDescriptor) = {
      BackendCallKey(createCall(workflowDescriptor)(finalCallForFqn(fqn)), None, 1)
    }

    /** Returns a file system safe version of the fqn. */
    def escapedFinalCallName = fqn.replaceAll("\\$", "__")
  }
}
