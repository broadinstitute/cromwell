package wdl.command

import cats.syntax.validated._
import common.validation.ErrorOr._
import wdl.AstTools.EnhancedAstNode
import wdl._
import wdl.exception.VariableNotFoundException
import wdl.expression.WdlFunctions
import wdl4s.parser.WdlParser.{Ast, SyntaxError, Terminal}
import wom.types.WomOptionalType
import wom.values._
import wom.{InstantiatedCommand, OptionalNotSuppliedException}

import scala.language.postfixOps
import scala.util.{Failure, Success}

object ParameterCommandPart {
  def apply(ast: Ast, wdlSyntaxErrorFormatter: WdlSyntaxErrorFormatter): ParameterCommandPart = {
    val attributes = ast.getAttribute("attributes").astListAsVector map { a =>
      val ast = a.asInstanceOf[Ast]
      (ast.getAttribute("key").sourceString, ast.getAttribute("value").sourceString)
    } toMap
    val expression = WdlExpression(ast.getAttribute("expr"))
    if ((attributes.contains("true") && !attributes.contains("false")) || (attributes.contains("false") && !attributes.contains("true"))) {
      // .head because we can't get here without there being at least one attribute
      val firstAttr = ast.getAttribute("attributes").astListAsVector.head.asInstanceOf[Ast].getAttribute("key").asInstanceOf[Terminal]
      throw new SyntaxError(wdlSyntaxErrorFormatter.trueAndFalseAttributesAreRequired(firstAttr))
    }
    new ParameterCommandPart(attributes, expression)
  }
}

case class ParameterCommandPart(attributes: Map[String, String], expression: WdlExpression) extends WdlCommandPart {
  def attributesToString: String = if (attributes.nonEmpty) attributes.map({case (k,v) => s"$k=${WomString(v).toWomString}"}).mkString(" ") + " " else ""
  override def toString: String = "${" + s"$attributesToString${expression.toWomString}" + "}"

  override def instantiate(declarations: Seq[Declaration], inputs: Map[String, WomValue], functions: WdlFunctions[WomValue],
                           valueMapper: (WomValue) => WomValue): ErrorOr[InstantiatedCommand] = {
    // This is a safety net.
    // In Cromwell's production code, optional declarations are always passed to instantiate, as WdlOptionalValue.none(type) if necessary.
    def lookupDeclaration(s: String) = declarations.collectFirst {
      // The backtick syntax (`s`) allows us to equality-check 's' against the match/case result:
      case Declaration(womType: WomOptionalType, `s`, _, _, _) => womType.none
    } getOrElse { throw VariableNotFoundException(s) }

    val lookup: String => WomValue = (s: String) => valueMapper(inputs.getOrElse(s, lookupDeclaration(s)))

    // Note that evaluating this expression may have the side effect of causing a file to be created if `writeFile`
    // is invoked. That file will be written to an "engine-relative" location which may be in cloud storage.
    val evaluatedCommandPartExpression: ErrorOr[WomValue] = expression.evaluate(lookup, functions) match {
      case Success(v) => v match {
        case WomOptionalValue(_, opt) => opt.getOrElse(defaultString).validNel
        case _ => v.validNel
      }
      case Failure(OptionalNotSuppliedException(_)) => defaultString.validNel
      case Failure(_) => s"Could not evaluate expression: ${expression.toWomString}".invalidNel
    }

    // Do the two arguments represent the same WomFile path.
    def representTheSamePath(womFile: WomFile, maybeWomFile: WomValue): Boolean = {
      Option(maybeWomFile) collect { case isWomFile: WomFile if isWomFile.value == womFile.value => true } isDefined
    }

    // Create the stringified version of the command and record any file created by `writeFile`.
    def instantiateCommand(value: WomValue): ErrorOr[InstantiatedCommand] = {
      valueMapper(value) match {
        case b: WomBoolean if attributes.contains("true") && attributes.contains("false") =>
          InstantiatedCommand(if (b.value) attributes.get("true").head else attributes.get("false").head).validNel
        case f: WomFile if !representTheSamePath(f, value) =>
          // Files generated by writeFiles have "engine-relative" paths which will be different from the container paths
          // calculated by `valueMapper`. "engine-relative" may mean either the non-Docker container path on the host
          // running Cromwell, or a cloud path. Capture these newly created files and their engine paths here.
          val enginePathFile = value.asInstanceOf[WomFile]
          InstantiatedCommand(f.valueString, List(enginePathFile)).validNel
        case f: WomFile =>
          InstantiatedCommand(f.valueString).validNel
        case p: WomPrimitive => InstantiatedCommand(p.valueString).validNel
        case a: WomArray if attributes.contains("sep") =>
          InstantiatedCommand(a.value.map(_.valueString).mkString(attributes.get("sep").head)).validNel
        case _: WomArray =>
          s"Expression '${expression.toString}' evaluated to an Array but no 'sep' was specified".invalidNel
        case _ =>
          s"Could not string-ify value: $value".invalidNel
      }
    }

    for {
      value <- evaluatedCommandPartExpression
      instantiatedCommand <- instantiateCommand(value)
    } yield instantiatedCommand
  }

  private def defaultString = {
    val value = if (attributes.contains("default")) attributes.get("default").head else ""
    WomString(value)
  }
}
