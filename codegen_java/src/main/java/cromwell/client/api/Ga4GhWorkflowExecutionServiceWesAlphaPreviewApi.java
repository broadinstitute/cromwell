/*
 * Cromwell Server REST API
 * Describes the REST API provided by a Cromwell server
 *
 * The version of the OpenAPI document: 30
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package cromwell.client.api;

import cromwell.client.ApiCallback;
import cromwell.client.ApiClient;
import cromwell.client.ApiException;
import cromwell.client.ApiResponse;
import cromwell.client.Configuration;
import cromwell.client.Pair;
import cromwell.client.ProgressRequestBody;
import cromwell.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.io.File;
import cromwell.client.model.RunId;
import cromwell.client.model.RunListResponse;
import cromwell.client.model.RunLog;
import cromwell.client.model.RunStatus;
import cromwell.client.model.ServiceInfo;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class Ga4GhWorkflowExecutionServiceWesAlphaPreviewApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public Ga4GhWorkflowExecutionServiceWesAlphaPreviewApi() {
        this(Configuration.getDefaultApiClient());
    }

    public Ga4GhWorkflowExecutionServiceWesAlphaPreviewApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for cancelRun
     * @param runId Run ID (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Workflow ID Not Found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cancelRunCall(String runId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/ga4gh/wes/v1/runs/{run_id}/cancel"
            .replaceAll("\\{" + "run_id" + "\\}", localVarApiClient.escapeString(runId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "googleoauth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelRunValidateBeforeCall(String runId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'runId' is set
        if (runId == null) {
            throw new ApiException("Missing the required parameter 'runId' when calling cancelRun(Async)");
        }
        

        okhttp3.Call localVarCall = cancelRunCall(runId, _callback);
        return localVarCall;

    }

    /**
     * Cancel run
     * Cancel a running workflow.
     * @param runId Run ID (required)
     * @return RunId
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Workflow ID Not Found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public RunId cancelRun(String runId) throws ApiException {
        ApiResponse<RunId> localVarResp = cancelRunWithHttpInfo(runId);
        return localVarResp.getData();
    }

    /**
     * Cancel run
     * Cancel a running workflow.
     * @param runId Run ID (required)
     * @return ApiResponse&lt;RunId&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Workflow ID Not Found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RunId> cancelRunWithHttpInfo(String runId) throws ApiException {
        okhttp3.Call localVarCall = cancelRunValidateBeforeCall(runId, null);
        Type localVarReturnType = new TypeToken<RunId>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Cancel run (asynchronously)
     * Cancel a running workflow.
     * @param runId Run ID (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Workflow ID Not Found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cancelRunAsync(String runId, final ApiCallback<RunId> _callback) throws ApiException {

        okhttp3.Call localVarCall = cancelRunValidateBeforeCall(runId, _callback);
        Type localVarReturnType = new TypeToken<RunId>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRunLog
     * @param runId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Workflow ID Not Found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRunLogCall(String runId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/ga4gh/wes/v1/runs/{run_id}"
            .replaceAll("\\{" + "run_id" + "\\}", localVarApiClient.escapeString(runId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "googleoauth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRunLogValidateBeforeCall(String runId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'runId' is set
        if (runId == null) {
            throw new ApiException("Missing the required parameter 'runId' when calling getRunLog(Async)");
        }
        

        okhttp3.Call localVarCall = getRunLogCall(runId, _callback);
        return localVarCall;

    }

    /**
     * Get run log
     * This endpoint provides detailed information about a given workflow run. The returned result has information about the outputs produced by this workflow (if available), a log object which allows the stderr and stdout to be retrieved, a log array so stderr/stdout for individual tasks can be retrieved, and the overall state of the workflow run (e.g. RUNNING, see the State section).
     * @param runId  (required)
     * @return RunLog
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Workflow ID Not Found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public RunLog getRunLog(String runId) throws ApiException {
        ApiResponse<RunLog> localVarResp = getRunLogWithHttpInfo(runId);
        return localVarResp.getData();
    }

    /**
     * Get run log
     * This endpoint provides detailed information about a given workflow run. The returned result has information about the outputs produced by this workflow (if available), a log object which allows the stderr and stdout to be retrieved, a log array so stderr/stdout for individual tasks can be retrieved, and the overall state of the workflow run (e.g. RUNNING, see the State section).
     * @param runId  (required)
     * @return ApiResponse&lt;RunLog&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Workflow ID Not Found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RunLog> getRunLogWithHttpInfo(String runId) throws ApiException {
        okhttp3.Call localVarCall = getRunLogValidateBeforeCall(runId, null);
        Type localVarReturnType = new TypeToken<RunLog>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get run log (asynchronously)
     * This endpoint provides detailed information about a given workflow run. The returned result has information about the outputs produced by this workflow (if available), a log object which allows the stderr and stdout to be retrieved, a log array so stderr/stdout for individual tasks can be retrieved, and the overall state of the workflow run (e.g. RUNNING, see the State section).
     * @param runId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Workflow ID Not Found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRunLogAsync(String runId, final ApiCallback<RunLog> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRunLogValidateBeforeCall(runId, _callback);
        Type localVarReturnType = new TypeToken<RunLog>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRunStatus
     * @param runId Run ID (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Workflow ID Not Found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRunStatusCall(String runId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/ga4gh/wes/v1/runs/{run_id}/status"
            .replaceAll("\\{" + "run_id" + "\\}", localVarApiClient.escapeString(runId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "googleoauth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRunStatusValidateBeforeCall(String runId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'runId' is set
        if (runId == null) {
            throw new ApiException("Missing the required parameter 'runId' when calling getRunStatus(Async)");
        }
        

        okhttp3.Call localVarCall = getRunStatusCall(runId, _callback);
        return localVarCall;

    }

    /**
     * Get run status
     * This provides an abbreviated (and likely fast depending on implementation) status of the running workflow, returning a simple result with the  overall state of the workflow run (e.g. RUNNING, see the State section).
     * @param runId Run ID (required)
     * @return RunStatus
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Workflow ID Not Found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public RunStatus getRunStatus(String runId) throws ApiException {
        ApiResponse<RunStatus> localVarResp = getRunStatusWithHttpInfo(runId);
        return localVarResp.getData();
    }

    /**
     * Get run status
     * This provides an abbreviated (and likely fast depending on implementation) status of the running workflow, returning a simple result with the  overall state of the workflow run (e.g. RUNNING, see the State section).
     * @param runId Run ID (required)
     * @return ApiResponse&lt;RunStatus&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Workflow ID Not Found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RunStatus> getRunStatusWithHttpInfo(String runId) throws ApiException {
        okhttp3.Call localVarCall = getRunStatusValidateBeforeCall(runId, null);
        Type localVarReturnType = new TypeToken<RunStatus>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get run status (asynchronously)
     * This provides an abbreviated (and likely fast depending on implementation) status of the running workflow, returning a simple result with the  overall state of the workflow run (e.g. RUNNING, see the State section).
     * @param runId Run ID (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Workflow ID Not Found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRunStatusAsync(String runId, final ApiCallback<RunStatus> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRunStatusValidateBeforeCall(runId, _callback);
        Type localVarReturnType = new TypeToken<RunStatus>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getServiceInfo
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getServiceInfoCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/ga4gh/wes/v1/service-info";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "googleoauth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getServiceInfoValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = getServiceInfoCall(_callback);
        return localVarCall;

    }

    /**
     * Get service info
     * May include information related (but not limited to) the workflow descriptor formats, versions supported, the WES API versions supported, and information about general service availability.
     * @return ServiceInfo
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public ServiceInfo getServiceInfo() throws ApiException {
        ApiResponse<ServiceInfo> localVarResp = getServiceInfoWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Get service info
     * May include information related (but not limited to) the workflow descriptor formats, versions supported, the WES API versions supported, and information about general service availability.
     * @return ApiResponse&lt;ServiceInfo&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ServiceInfo> getServiceInfoWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getServiceInfoValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<ServiceInfo>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get service info (asynchronously)
     * May include information related (but not limited to) the workflow descriptor formats, versions supported, the WES API versions supported, and information about general service availability.
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getServiceInfoAsync(final ApiCallback<ServiceInfo> _callback) throws ApiException {

        okhttp3.Call localVarCall = getServiceInfoValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<ServiceInfo>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listRuns
     * @param pageSize OPTIONAL The preferred number of workflow runs to return in a page. If not provided, the implementation should use a default page size. The implementation must not return more items than &#x60;page_size&#x60;, but it may return fewer.  Clients should not assume that if fewer than &#x60;page_size&#x60; items are returned that all items have been returned.  The availability of additional pages is indicated by the value of &#x60;next_page_token&#x60; in the response. (optional)
     * @param pageToken OPTIONAL Token to use to indicate where to start getting results. If unspecified, return the first page of results. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Malformed Workflow ID </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listRunsCall(Long pageSize, String pageToken, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/ga4gh/wes/v1/runs";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pageSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_size", pageSize));
        }

        if (pageToken != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_token", pageToken));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "googleoauth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listRunsValidateBeforeCall(Long pageSize, String pageToken, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = listRunsCall(pageSize, pageToken, _callback);
        return localVarCall;

    }

    /**
     * List runs
     * Runs are listed from newest to oldest. When paging through the list, the client should not make assumptions about live updates, but should assume the contents of the list reflect the workflow list at the moment that the first page is requested. To monitor a specific workflow run, use GetRunStatus or GetRunLog.
     * @param pageSize OPTIONAL The preferred number of workflow runs to return in a page. If not provided, the implementation should use a default page size. The implementation must not return more items than &#x60;page_size&#x60;, but it may return fewer.  Clients should not assume that if fewer than &#x60;page_size&#x60; items are returned that all items have been returned.  The availability of additional pages is indicated by the value of &#x60;next_page_token&#x60; in the response. (optional)
     * @param pageToken OPTIONAL Token to use to indicate where to start getting results. If unspecified, return the first page of results. (optional)
     * @return RunListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Malformed Workflow ID </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public RunListResponse listRuns(Long pageSize, String pageToken) throws ApiException {
        ApiResponse<RunListResponse> localVarResp = listRunsWithHttpInfo(pageSize, pageToken);
        return localVarResp.getData();
    }

    /**
     * List runs
     * Runs are listed from newest to oldest. When paging through the list, the client should not make assumptions about live updates, but should assume the contents of the list reflect the workflow list at the moment that the first page is requested. To monitor a specific workflow run, use GetRunStatus or GetRunLog.
     * @param pageSize OPTIONAL The preferred number of workflow runs to return in a page. If not provided, the implementation should use a default page size. The implementation must not return more items than &#x60;page_size&#x60;, but it may return fewer.  Clients should not assume that if fewer than &#x60;page_size&#x60; items are returned that all items have been returned.  The availability of additional pages is indicated by the value of &#x60;next_page_token&#x60; in the response. (optional)
     * @param pageToken OPTIONAL Token to use to indicate where to start getting results. If unspecified, return the first page of results. (optional)
     * @return ApiResponse&lt;RunListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Malformed Workflow ID </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RunListResponse> listRunsWithHttpInfo(Long pageSize, String pageToken) throws ApiException {
        okhttp3.Call localVarCall = listRunsValidateBeforeCall(pageSize, pageToken, null);
        Type localVarReturnType = new TypeToken<RunListResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List runs (asynchronously)
     * Runs are listed from newest to oldest. When paging through the list, the client should not make assumptions about live updates, but should assume the contents of the list reflect the workflow list at the moment that the first page is requested. To monitor a specific workflow run, use GetRunStatus or GetRunLog.
     * @param pageSize OPTIONAL The preferred number of workflow runs to return in a page. If not provided, the implementation should use a default page size. The implementation must not return more items than &#x60;page_size&#x60;, but it may return fewer.  Clients should not assume that if fewer than &#x60;page_size&#x60; items are returned that all items have been returned.  The availability of additional pages is indicated by the value of &#x60;next_page_token&#x60; in the response. (optional)
     * @param pageToken OPTIONAL Token to use to indicate where to start getting results. If unspecified, return the first page of results. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Malformed Workflow ID </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listRunsAsync(Long pageSize, String pageToken, final ApiCallback<RunListResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = listRunsValidateBeforeCall(pageSize, pageToken, _callback);
        Type localVarReturnType = new TypeToken<RunListResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for runWorkflow
     * @param workflowParams  (optional)
     * @param workflowType  (optional)
     * @param workflowTypeVersion  (optional)
     * @param tags  (optional)
     * @param workflowEngineParameters  (optional)
     * @param workflowUrl  (optional)
     * @param workflowAttachment  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Malformed Workflow ID </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call runWorkflowCall(String workflowParams, String workflowType, String workflowTypeVersion, String tags, String workflowEngineParameters, String workflowUrl, List<File> workflowAttachment, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/ga4gh/wes/v1/runs";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (workflowParams != null) {
            localVarFormParams.put("workflow_params", workflowParams);
        }

        if (workflowType != null) {
            localVarFormParams.put("workflow_type", workflowType);
        }

        if (workflowTypeVersion != null) {
            localVarFormParams.put("workflow_type_version", workflowTypeVersion);
        }

        if (tags != null) {
            localVarFormParams.put("tags", tags);
        }

        if (workflowEngineParameters != null) {
            localVarFormParams.put("workflow_engine_parameters", workflowEngineParameters);
        }

        if (workflowUrl != null) {
            localVarFormParams.put("workflow_url", workflowUrl);
        }

        if (workflowAttachment != null) {
            localVarFormParams.put("workflow_attachment", workflowAttachment);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "googleoauth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call runWorkflowValidateBeforeCall(String workflowParams, String workflowType, String workflowTypeVersion, String tags, String workflowEngineParameters, String workflowUrl, List<File> workflowAttachment, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = runWorkflowCall(workflowParams, workflowType, workflowTypeVersion, tags, workflowEngineParameters, workflowUrl, workflowAttachment, _callback);
        return localVarCall;

    }

    /**
     * Run workflow
     * This endpoint creates a new workflow run and returns a &#x60;RunId&#x60; to monitor its progress.  The &#x60;workflow_attachment&#x60; array may be used to upload files that are required to execute the workflow, including the primary workflow, tools imported by the workflow, other files referenced by the workflow, or files which are part of the input.  The implementation should stage these files to a temporary directory and execute the workflow from there. These parts must have a Content-Disposition header with a \&quot;filename\&quot; provided for each part.  Filenames may include subdirectories, but must not include references to parent directories with &#39;..&#39; -- implementations should guard against maliciously constructed filenames.  The &#x60;workflow_url&#x60; is either an absolute URL to a workflow file that is accessible by the WES endpoint, or a relative URL corresponding to one of the files attached using &#x60;workflow_attachment&#x60;.  The &#x60;workflow_params&#x60; JSON object specifies input parameters, such as input files.  The exact format of the JSON object depends on the conventions of the workflow language being used.  Input files should either be absolute URLs, or relative URLs corresponding to files uploaded using &#x60;workflow_attachment&#x60;.  The WES endpoint must understand and be able to access URLs supplied in the input.  This is implementation specific.  The &#x60;workflow_type&#x60; is the type of workflow language and must be \&quot;CWL\&quot; or \&quot;WDL\&quot; currently (or another alternative  supported by this WES instance).  The &#x60;workflow_type_version&#x60; is the version of the workflow language submitted and must be one supported by this WES instance.  See the &#x60;RunRequest&#x60; documentation for details about other fields.
     * @param workflowParams  (optional)
     * @param workflowType  (optional)
     * @param workflowTypeVersion  (optional)
     * @param tags  (optional)
     * @param workflowEngineParameters  (optional)
     * @param workflowUrl  (optional)
     * @param workflowAttachment  (optional)
     * @return RunId
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Malformed Workflow ID </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public RunId runWorkflow(String workflowParams, String workflowType, String workflowTypeVersion, String tags, String workflowEngineParameters, String workflowUrl, List<File> workflowAttachment) throws ApiException {
        ApiResponse<RunId> localVarResp = runWorkflowWithHttpInfo(workflowParams, workflowType, workflowTypeVersion, tags, workflowEngineParameters, workflowUrl, workflowAttachment);
        return localVarResp.getData();
    }

    /**
     * Run workflow
     * This endpoint creates a new workflow run and returns a &#x60;RunId&#x60; to monitor its progress.  The &#x60;workflow_attachment&#x60; array may be used to upload files that are required to execute the workflow, including the primary workflow, tools imported by the workflow, other files referenced by the workflow, or files which are part of the input.  The implementation should stage these files to a temporary directory and execute the workflow from there. These parts must have a Content-Disposition header with a \&quot;filename\&quot; provided for each part.  Filenames may include subdirectories, but must not include references to parent directories with &#39;..&#39; -- implementations should guard against maliciously constructed filenames.  The &#x60;workflow_url&#x60; is either an absolute URL to a workflow file that is accessible by the WES endpoint, or a relative URL corresponding to one of the files attached using &#x60;workflow_attachment&#x60;.  The &#x60;workflow_params&#x60; JSON object specifies input parameters, such as input files.  The exact format of the JSON object depends on the conventions of the workflow language being used.  Input files should either be absolute URLs, or relative URLs corresponding to files uploaded using &#x60;workflow_attachment&#x60;.  The WES endpoint must understand and be able to access URLs supplied in the input.  This is implementation specific.  The &#x60;workflow_type&#x60; is the type of workflow language and must be \&quot;CWL\&quot; or \&quot;WDL\&quot; currently (or another alternative  supported by this WES instance).  The &#x60;workflow_type_version&#x60; is the version of the workflow language submitted and must be one supported by this WES instance.  See the &#x60;RunRequest&#x60; documentation for details about other fields.
     * @param workflowParams  (optional)
     * @param workflowType  (optional)
     * @param workflowTypeVersion  (optional)
     * @param tags  (optional)
     * @param workflowEngineParameters  (optional)
     * @param workflowUrl  (optional)
     * @param workflowAttachment  (optional)
     * @return ApiResponse&lt;RunId&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Malformed Workflow ID </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RunId> runWorkflowWithHttpInfo(String workflowParams, String workflowType, String workflowTypeVersion, String tags, String workflowEngineParameters, String workflowUrl, List<File> workflowAttachment) throws ApiException {
        okhttp3.Call localVarCall = runWorkflowValidateBeforeCall(workflowParams, workflowType, workflowTypeVersion, tags, workflowEngineParameters, workflowUrl, workflowAttachment, null);
        Type localVarReturnType = new TypeToken<RunId>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Run workflow (asynchronously)
     * This endpoint creates a new workflow run and returns a &#x60;RunId&#x60; to monitor its progress.  The &#x60;workflow_attachment&#x60; array may be used to upload files that are required to execute the workflow, including the primary workflow, tools imported by the workflow, other files referenced by the workflow, or files which are part of the input.  The implementation should stage these files to a temporary directory and execute the workflow from there. These parts must have a Content-Disposition header with a \&quot;filename\&quot; provided for each part.  Filenames may include subdirectories, but must not include references to parent directories with &#39;..&#39; -- implementations should guard against maliciously constructed filenames.  The &#x60;workflow_url&#x60; is either an absolute URL to a workflow file that is accessible by the WES endpoint, or a relative URL corresponding to one of the files attached using &#x60;workflow_attachment&#x60;.  The &#x60;workflow_params&#x60; JSON object specifies input parameters, such as input files.  The exact format of the JSON object depends on the conventions of the workflow language being used.  Input files should either be absolute URLs, or relative URLs corresponding to files uploaded using &#x60;workflow_attachment&#x60;.  The WES endpoint must understand and be able to access URLs supplied in the input.  This is implementation specific.  The &#x60;workflow_type&#x60; is the type of workflow language and must be \&quot;CWL\&quot; or \&quot;WDL\&quot; currently (or another alternative  supported by this WES instance).  The &#x60;workflow_type_version&#x60; is the version of the workflow language submitted and must be one supported by this WES instance.  See the &#x60;RunRequest&#x60; documentation for details about other fields.
     * @param workflowParams  (optional)
     * @param workflowType  (optional)
     * @param workflowTypeVersion  (optional)
     * @param tags  (optional)
     * @param workflowEngineParameters  (optional)
     * @param workflowUrl  (optional)
     * @param workflowAttachment  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Successful Request </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Malformed Workflow ID </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Invalid submission request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Workflow in terminal status </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call runWorkflowAsync(String workflowParams, String workflowType, String workflowTypeVersion, String tags, String workflowEngineParameters, String workflowUrl, List<File> workflowAttachment, final ApiCallback<RunId> _callback) throws ApiException {

        okhttp3.Call localVarCall = runWorkflowValidateBeforeCall(workflowParams, workflowType, workflowTypeVersion, tags, workflowEngineParameters, workflowUrl, workflowAttachment, _callback);
        Type localVarReturnType = new TypeToken<RunId>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
