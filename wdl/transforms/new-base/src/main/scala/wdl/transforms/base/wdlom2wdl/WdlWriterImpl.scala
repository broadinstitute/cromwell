package wdl.transforms.base.wdlom2wdl

import wdl.model.draft3.elements.ExpressionElement._
import wdl.model.draft3.elements._
import wom.types._
import org.apache.commons.text.StringEscapeUtils

object WdlWriterImpl {

  // Auto-generated by simulacrum
  import WdlWriter.ops._

  implicit val stringPieceWriter: WdlWriter[StringPiece] = new WdlWriter[StringPiece] {
    override def toWdlV1(a: StringPiece): String = a match {
      case a: StringLiteral => a.value
      case a: StringPlaceholder => "~{" + a.expr.toWdlV1 + "}"
      case NewlineEscape => "\\n"
      case TabEscape => "\\t"
      case BackslashEscape => "\\\\"
      case SingleQuoteEscape => "\\'"
      case DoubleQuoteEscape => "\\\""
      case UnicodeCharacterEscape(codePoint) => s"\\u${"%04x".format(codePoint)}"
    }
  }

  implicit val indexAccessWriter: WdlWriter[IndexAccess] = a =>
    s"${expressionElementWriter.toWdlV1(a.expressionElement)}[${expressionElementWriter.toWdlV1(a.index)}]"

  // Recursive references must be explicit
  implicit val expressionElementWriter: WdlWriter[ExpressionElement] = new WdlWriter[ExpressionElement] {
    override def toWdlV1(a: ExpressionElement) = a match {
      case a: PrimitiveLiteralExpressionElement => a.toWdlV1
      case a: NoneLiteralElement.type => a.toWdlV1
      case a: StringExpression => "\"" + a.pieces.map(_.toWdlV1).mkString + "\""
      case a: StringLiteral => "\"" + StringEscapeUtils.escapeJava(a.value) + "\""
      case a: ObjectLiteral =>
        "object { " + a.elements
          .map { pair =>
            pair._1 + ": " + expressionElementWriter.toWdlV1(pair._2)
          }
          .mkString(", ") + " }"
      case a: StructLiteral =>
        a.structTypeName + " { " + a.elements
          .map { pair =>
            pair._1 + ": " + expressionElementWriter.toWdlV1(pair._2)
          }
          .mkString(", ") + " }"
      case a: ArrayLiteral =>
        "[" + a.elements.map(expressionElementWriter.toWdlV1).mkString(", ") + "]"
      case a: MapLiteral =>
        "{ " + a.elements
          .map { pair =>
            expressionElementWriter.toWdlV1(pair._1) + ": " + expressionElementWriter.toWdlV1(pair._2)
          }
          .mkString(", ") + " }"
      case a: PairLiteral =>
        s"(${expressionElementWriter.toWdlV1(a.left)}, ${expressionElementWriter.toWdlV1(a.right)})"
      case a: UnaryOperation => a.toWdlV1
      case a: BinaryOperation => a.toWdlV1
      case a: TernaryIf =>
        s"if ${expressionElementWriter.toWdlV1(a.condition)} then ${expressionElementWriter.toWdlV1(a.ifTrue)} else ${expressionElementWriter
            .toWdlV1(a.ifFalse)}"
      case a: FunctionCallElement => a.toWdlV1
      case a: IdentifierLookup => a.identifier
      case a: IdentifierMemberAccess => a.toWdlV1
      case a: ExpressionMemberAccess =>
        s"${expressionElementWriter.toWdlV1(a.expression)}.${a.memberAccessTail.toList.mkString(".")}"
      case a: IndexAccess => a.toWdlV1
      case a: ExpressionLiteralElement => a.expression
    }
  }

  implicit val unaryOperationWriter: WdlWriter[UnaryOperation] = new WdlWriter[UnaryOperation] {
    override def toWdlV1(a: UnaryOperation): String = a match {
      case a: LogicalNot => s"!(${a.argument.toWdlV1})"
      case a: UnaryNegation => s"-(${a.argument.toWdlV1})"
      case a: UnaryPlus => s"+(${a.argument.toWdlV1})"
    }
  }

  implicit val identifierMemberAccessWriter: WdlWriter[IdentifierMemberAccess] = new WdlWriter[IdentifierMemberAccess] {
    override def toWdlV1(a: IdentifierMemberAccess): String =
      s"${a.first}.${a.second}" + (if (a.memberAccessTail.nonEmpty) {
                                     "." + a.memberAccessTail.mkString(".")
                                   } else {
                                     ""
                                   })
  }

  implicit val binaryOperationWriter: WdlWriter[BinaryOperation] = new WdlWriter[BinaryOperation] {
    override def toWdlV1(a: BinaryOperation) = {
      val op = a match {
        case _: LogicalOr => "||"
        case _: LogicalAnd => "&&"
        case _: Equals => "=="
        case _: NotEquals => "!="
        case _: LessThan => "<"
        case _: LessThanOrEquals => "<="
        case _: GreaterThan => ">"
        case _: GreaterThanOrEquals => ">="
        case _: Add => "+"
        case _: Subtract => "-"
        case _: Multiply => "*"
        case _: Divide => "/"
        case _: Remainder => "%"
      }

      s"(${a.left.toWdlV1} $op ${a.right.toWdlV1})"
    }
  }

  object CallElementWriter {
    def withoutBody(a: CallElement): String = {
      val aliasExpression = a.alias match {
        case Some(alias) => s" as $alias"
        case None => ""
      }

      val afterExpression = if (a.afters.nonEmpty) a.afters.map(after => s" after $after").mkString(" ") else ""

      s"call ${a.callableReference}$aliasExpression$afterExpression"
    }
  }

  implicit val typeElementWriter: WdlWriter[TypeElement] = new WdlWriter[TypeElement] {
    override def toWdlV1(a: TypeElement) = a match {
      case a: PrimitiveTypeElement => a.primitiveType.toWdlV1
      case a: ArrayTypeElement => s"Array[${typeElementWriter.toWdlV1(a.inner)}]"
      case a: MapTypeElement =>
        s"Map[${typeElementWriter.toWdlV1(a.keyType)}, ${typeElementWriter.toWdlV1(a.valueType)}]"
      case a: OptionalTypeElement => s"${typeElementWriter.toWdlV1(a.maybeType)}?"
      case a: NonEmptyTypeElement => s"${typeElementWriter.toWdlV1(a.arrayType)}+"
      case a: PairTypeElement =>
        s"Pair[${typeElementWriter.toWdlV1(a.leftType)}, ${typeElementWriter.toWdlV1(a.rightType)}]"
      case _: ObjectTypeElement.type => "Object"
      case a: TypeAliasElement => a.alias
    }
  }

  implicit val primitiveTypeElementWriter: WdlWriter[WomPrimitiveType] = new WdlWriter[WomPrimitiveType] {
    override def toWdlV1(a: WomPrimitiveType) = a.stableName
  }

  implicit val placeholderAttributeSetWriter: WdlWriter[PlaceholderAttributeSet] =
    new WdlWriter[PlaceholderAttributeSet] {
      override def toWdlV1(a: PlaceholderAttributeSet): String = {
        val attrStrings = Map(
          "sep" -> a.sepAttribute,
          "true" -> a.trueAttribute,
          "false" -> a.falseAttribute,
          "default" -> a.defaultAttribute
        ).collect { case (attrKey: String, Some(value)) => attrKey + "=\"" + value + "\"" }

        if (attrStrings.isEmpty) "" else attrStrings.mkString(start = "", sep = " ", end = " ")
      }
    }

  implicit val functionCallElementWriter: WdlWriter[FunctionCallElement] = new WdlWriter[FunctionCallElement] {
    override def toWdlV1(a: FunctionCallElement): String = a match {
      case _: StdoutElement.type => "stdout()"
      case _: StderrElement.type => "stderr()"
      case a: OneParamFunctionCallElement => a.toWdlV1
      case a: OneOrTwoParamFunctionCallElement => a.toWdlV1
      case a: TwoParamFunctionCallElement => a.toWdlV1
      case a: Sub => s"sub(${a.input.toWdlV1}, ${a.pattern.toWdlV1}, ${a.replace.toWdlV1})"
      case a: SubPosix => s"sub(${a.input.toWdlV1}, ${a.pattern.toWdlV1}, ${a.replace.toWdlV1})"
    }
  }

  implicit val oneParamFunctionCallElementWriter: WdlWriter[OneParamFunctionCallElement] =
    new WdlWriter[OneParamFunctionCallElement] {
      override def toWdlV1(a: OneParamFunctionCallElement): String = {
        val fn = a match {
          case _: ReadLines => "read_lines"
          case _: ReadTsv => "read_tsv"
          case _: ReadMap => "read_map"
          case _: ReadObject => "read_object"
          case _: ReadObjects => "read_objects"
          case _: ReadJson => "read_json"
          case _: ReadInt => "read_int"
          case _: ReadString => "read_string"
          case _: ReadFloat => "read_float"
          case _: ReadBoolean => "read_boolean"
          case _: WriteLines => "write_lines"
          case _: WriteTsv => "write_tsv"
          case _: WriteMap => "write_map"
          case _: WriteObject => "write_object"
          case _: WriteObjects => "write_objects"
          case _: WriteJson => "write_json"
          case _: Range => "range"
          case _: Transpose => "transpose"
          case _: Length => "length"
          case _: Flatten => "flatten"
          case _: SelectFirst => "select_first"
          case _: SelectAll => "select_all"
          case _: Defined => "defined"
          case _: Floor => "floor"
          case _: Ceil => "ceil"
          case _: Round => "round"
          case _: Glob => "glob"
          case _: Quote => "quote"
          case _: SQuote => "squote"
          case _: Keys => "keys"
          case _: AsMap => "as_map"
          case _: AsPairs => "as_pairs"
          case _: CollectByKey => "collect_by_key"
          case _: Unzip => "unzip"
        }

        s"$fn(${a.param.toWdlV1})"
      }
    }

  implicit val oneOrTwoParamFunctionCallElementWriter: WdlWriter[OneOrTwoParamFunctionCallElement] =
    new WdlWriter[OneOrTwoParamFunctionCallElement] {
      override def toWdlV1(a: OneOrTwoParamFunctionCallElement): String =
        (a, a.secondParam) match {
          case (_: Size, Some(unit)) => s"size(${a.firstParam.toWdlV1}, ${unit.toWdlV1})"
          case (_: Size, None) => s"size(${a.firstParam.toWdlV1})"
          case (_: Basename, Some(suffix)) => s"basename(${a.firstParam.toWdlV1}, ${suffix.toWdlV1})"
          case (_: Basename, None) => s"basename(${a.firstParam.toWdlV1})"
        }
    }

  implicit val twoParamFunctionCallElementWriter: WdlWriter[TwoParamFunctionCallElement] =
    new WdlWriter[TwoParamFunctionCallElement] {
      override def toWdlV1(a: TwoParamFunctionCallElement): String = {
        def functionCall(name: String) = s"$name(${a.arg1.toWdlV1}, ${a.arg2.toWdlV1})"

        a match {
          case _: Zip => functionCall("zip")
          case _: Cross => functionCall("cross")
          case _: Prefix => functionCall("prefix")
          case _: Suffix => functionCall("suffix")
          case _: Min => functionCall("min")
          case _: Max => functionCall("max")
          case _: Sep => functionCall("sep")
        }
      }
    }

  implicit val kvPairWriter: WdlWriter[KvPair] = new WdlWriter[KvPair] {
    override def toWdlV1(a: KvPair): String = s"${a.key} = ${a.value.toWdlV1}"
  }

  implicit val primitiveLiteralExpressionElementWriter: WdlWriter[PrimitiveLiteralExpressionElement] =
    new WdlWriter[PrimitiveLiteralExpressionElement] {
      override def toWdlV1(a: PrimitiveLiteralExpressionElement) = a.value.toWomString
    }

  implicit val noneLiteralExpressionElementWriter: WdlWriter[NoneLiteralElement.type] =
    new WdlWriter[NoneLiteralElement.type] {
      override def toWdlV1(a: NoneLiteralElement.type): String = "None"
    }
}
