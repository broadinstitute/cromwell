package cromwell.backend.google.pipelines.v2alpha1.api

import java.util.UUID

import com.google.api.services.genomics.v2alpha1.model.{Action, Mount}
import common.util.StringUtil._
import cromwell.backend.google.pipelines.common.api.PipelinesApiRequestFactory.CreatePipelineParameters
import cromwell.backend.google.pipelines.v2alpha1.PipelinesConversions._
import cromwell.backend.google.pipelines.v2alpha1.api.ActionBuilder._
import cromwell.backend.google.pipelines.v2alpha1.api.Delocalization._
import cromwell.backend.io.JobPaths
import cromwell.core.StandardPaths
import cromwell.core.path.Path

import scala.collection.JavaConverters._

object Delocalization {
  private val logsRoot = "/google/logs"
}

trait Delocalization {

  private def aggregatedLog = s"$logsRoot/output"

  private def delocalizeLogsAction(gcsLogPath: String, projectId: String) = {
    gsutilAsText("-u", projectId, "-m", "cp", "-r", "/google/logs", gcsLogPath)(flags = List(ActionFlag.AlwaysRun))
  }

  // Action logs are now located in the pipelines-logs directory. The aggregated log is copied from this pipelines-logs
  // directory, but in order to capture only the user command stdout/err and not the stdout/err from the whole exec.sh
  // script, this copies the stdout/err files generated by the user command not those generated by the action.
  private def copyLogsToLegacyPaths(callExecutionContainerRoot: Path, mounts: List[Mount],
                                    cloudStdout: String, cloudStderr: String, gcsLegacyLogPath: String, projectId: String): List[Action] = {
    def basename(value: String): String = value.substring(value.lastIndexOf('/') + 1)
    val List(containerStdout, containerStderr) = List(cloudStdout, cloudStderr) map { s => callExecutionContainerRoot.resolve(basename(s)).pathAsString }

    List(
      gsutilAsText("-u", projectId, "cp", containerStdout, cloudStdout)(mounts = mounts, flags = List(ActionFlag.AlwaysRun)),
      gsutilAsText("-u", projectId, "cp", containerStderr, cloudStderr)(mounts = mounts, flags = List(ActionFlag.AlwaysRun)),
      gsutilAsText("-u", projectId, "cp", aggregatedLog, gcsLegacyLogPath)(flags = List(ActionFlag.AlwaysRun))
    )
  }

  private def parseOutputJsonAction(containerCallRoot: String, outputDirectory: String, outputFile: String, mounts: List[Mount]): Action = {
    val commands = List(
      "-c",
      // Create the directory where the output of jq will be written
      s"mkdir -p $outputDirectory &&" +
      // Read the content of cwl.output.json - redirect stderr to /dev/null so it doesn't fail if there's no cwl.output.json
      s" cat ${containerCallRoot.ensureSlashed}cwl.output.json 2>/dev/null" +
        // Pipe the result to jq. Parse the json and traverse it looking for "path" values
      " | jq -r '.. | .path? // empty'" +
      // Redirect the result to a file that can be used in the next action to delocalize the extracted files / directories
      s" > $outputFile"
    )

    ActionBuilder
      .withImage("stedolan/jq@sha256:a61ed0bca213081b64be94c5e1b402ea58bc549f457c2682a86704dd55231e09")
      .setCommands(commands.asJava)
      .withMounts(mounts)
      .setEntrypoint("/bin/bash")
      // Saves us some time if something else fails before we get to run this action
      .withFlags(List(ActionFlag.DisableImagePrefetch))
  }

  private def delocalizeOutputJsonFilesAction(cloudCallRoot: String, inputFile: String, mounts: List[Mount]): Action = {
    val sedStripSlashPrefix = "s/^\\///"
    val commands = List(
      "/bin/bash",
      "-c",
        // Read the file containing files to delocalize
        s"cat $inputFile 2>/dev/null" +
        /*
         * Pipe the result to xargs and execute a gsutil cp command, appending the path to the cloudCallRoot
         * Use a subshell so that we can strip the potential leading slash from the local path and avoid double slashes in the cloud path
         * It also seems that the gsutil fails without sub shelling
         * We can't use the gsutil -I flag here because it would lose the directory structure once it gets copied to the bucket
         * sh -c 'gsutil cp % $(echo % | sed -e "s/^\///")'
         */
        s""" | xargs -I % sh -c 'gsutil -m cp -r % ${cloudCallRoot.ensureSlashed}$$(echo % | sed -e "$sedStripSlashPrefix")'"""
    )

    ActionBuilder
      .cloudSdkAction
      .setCommands(commands.asJava)
      .withMounts(mounts)
  }

  /**
    * The user action number is the index of the user's action in the list of actions
    * It's used to copy stdout / stderr and the logs back to the execution directory
    */
  def deLocalizeActions(createPipelineParameters: CreatePipelineParameters,
                        mounts: List[Mount],
                        userActionNumber: Int,
                        jobPaths: Option[JobPaths]): List[Action] = {
    val cloudCallRoot = createPipelineParameters.cloudCallRoot.pathAsString
    val callExecutionContainerRoot = createPipelineParameters.commandScriptContainerPath.parent

    val gcsLogDirectoryPath = createPipelineParameters.cloudCallRoot / "pipelines-logs"
    val gcsLegacyLogPath = createPipelineParameters.logGcsPath.pathAsString

    val parent = createPipelineParameters.logGcsPath.parent

    // The cloud path of the standard output or error file as a String.
    def cloudStandardFile(path: StandardPaths => Path, name: String): String =
      jobPaths.map(j => parent.resolve(path(j.standardPaths).getFileName))
        .getOrElse(parent.resolve(createPipelineParameters.logGcsPath.nameWithoutExtensionNoIo + s"-$name.log"))
        .pathAsString

    val List(stdoutPath, stderrPath) = List[(StandardPaths => Path, String)]((_.output, "stdout"), (_.error, "stderr")) map (cloudStandardFile _).tupled

    /*
     * CWL specific delocalization. For now this always runs, even for WDL jobs.
     * Ideally temporaryFofnForCwlOutputJson should be somewhere else than the execution directory (we could mount anther directory)
     * However because it runs after everything else there's no risk of polluting the task's results and the random ID ensures we don't override anything
     */
    val temporaryFofnDirectoryForCwlOutputJson = callExecutionContainerRoot.pathAsString.ensureSlashed + UUID.randomUUID().toString.split("-")(0)
    val temporaryFofnForCwlOutputJson = temporaryFofnDirectoryForCwlOutputJson + "/cwl_output_json_references.txt"
    val parseAction = parseOutputJsonAction(callExecutionContainerRoot.pathAsString, temporaryFofnDirectoryForCwlOutputJson, temporaryFofnForCwlOutputJson, mounts)
    val delocalizeAction = delocalizeOutputJsonFilesAction(cloudCallRoot, temporaryFofnForCwlOutputJson, mounts)

    val projectId = createPipelineParameters.projectId

    createPipelineParameters.outputParameters.map(_.toAction(mounts, projectId)) ++
      List(parseAction, delocalizeAction) ++
      copyLogsToLegacyPaths(callExecutionContainerRoot, mounts, stdoutPath, stderrPath, gcsLegacyLogPath, projectId) :+
      delocalizeLogsAction(gcsLogDirectoryPath.pathAsString, projectId)
  }
}
