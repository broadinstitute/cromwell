diff --git a/cwl/src/main/scala/cwl/ArgumentToCommandPart.scala b/cwl/src/main/scala/cwl/ArgumentToCommandPart.scala
index 1b1da6e..29a5e51 100644
--- a/cwl/src/main/scala/cwl/ArgumentToCommandPart.scala
+++ b/cwl/src/main/scala/cwl/ArgumentToCommandPart.scala
@@ -1,20 +1,12 @@
 package cwl
 
-import scala.Function._
 import shapeless._
 import wdl.command.StringCommandPart
 
 object ArgumentToCommandPart extends Poly1 {
-  implicit def script = at[Expression] { const(StringCommandPart(null)) }
+  implicit def script = at[Expression] { CwlExpressionCommandPart.apply }
 
-  implicit def clb = at[CommandLineBinding] {
-      //TODO: This option.get will not hold up under scrutiny
-      _.valueFrom.map(_.fold(StringOrExpressionToCommandPart)).get
+  implicit def clb = at[CommandLineBinding] { CwlArgumentCommandPart.apply }
 
-      //TODO: Shell Quote = false?
-  }
-
-  implicit def string = at[String] {
-    StringCommandPart.apply
-  }
+  implicit def string = at[String] { StringCommandPart.apply }
 }
diff --git a/cwl/src/main/scala/cwl/CommandOutputBinding.scala b/cwl/src/main/scala/cwl/CommandOutputBinding.scala
index e6e9a95..72bd484 100644
--- a/cwl/src/main/scala/cwl/CommandOutputBinding.scala
+++ b/cwl/src/main/scala/cwl/CommandOutputBinding.scala
@@ -2,9 +2,12 @@ package cwl
 
 import cwl.CommandOutputBinding.Glob
 import shapeless.{:+:, CNil}
-import wdl.types.{WdlArrayType, WdlMapType,  WdlStringType}
+import wdl.types.{WdlArrayType, WdlMapType, WdlStringType}
 import wdl.values.{WdlArray, WdlMap, WdlString, WdlValue}
 import wom.expression.IoFunctionSet
+import scala.language.postfixOps
+import scala.concurrent.Await
+import scala.concurrent.duration._
 
 /** @see <a href="http://www.commonwl.org/v1.0/Workflow.html#CommandOutputBinding">CommandOutputBinding</a> */
 case class CommandOutputBinding(
@@ -63,9 +66,10 @@ case class CommandOutputBinding(
 
   private def load64KiB(path: String, ioFunctionSet: IoFunctionSet): String = {
     // This suggests the IoFunctionSet should have a length-limited read API as both CWL and WDL support this concept.
-    // val content = ioFunctionSet.readFile(path)
-    val content = better.files.File(path).bytes.take(64 * 1024).toArray
-    new String(content)
+    val content = ioFunctionSet.readFile(path)
+
+    //TODO: propagate IO, Try, or Future or something all the way out via "commandOutputBindingtoWdlValue" signature
+    Await.result(content, 5 seconds)
   }
 }
 
diff --git a/cwl/src/main/scala/cwl/CwlExpressionCommandPart.scala b/cwl/src/main/scala/cwl/CwlExpressionCommandPart.scala
index 7ac6689..ac866f1 100644
--- a/cwl/src/main/scala/cwl/CwlExpressionCommandPart.scala
+++ b/cwl/src/main/scala/cwl/CwlExpressionCommandPart.scala
@@ -1,6 +1,7 @@
 package cwl
 
-import wdl.values.WdlValue
+import shapeless.{Inl, Inr}
+import wdl.values.{WdlSingleFile, WdlString, WdlValue}
 import wom.CommandPart
 import wom.expression.IoFunctionSet
 import wom.graph.LocalName
@@ -19,3 +20,25 @@ case class CwlExpressionCommandPart(expr: Expression) extends CommandPart {
   }
 }
 
+case class CwlArgumentCommandPart(argument: CommandLineBinding) extends CommandPart {
+  override def instantiate(inputsMap: Map[LocalName, WdlValue],
+                           functions: IoFunctionSet,
+                           valueMapper: (WdlValue) => WdlValue) = {
+
+    val pc = ParameterContext.Empty.withInputs(inputsMap.map({
+      case (LocalName(localName), WdlSingleFile(path)) => localName -> WdlString(path)
+      case (LocalName(localName), value) => localName -> value
+    }), functions)
+
+    val wdlValue: WdlValue= argument match {
+      case CommandLineBinding(_, _, _, _, _, Some(Inl(expression: Expression)), Some(false)) =>
+        expression.fold(EvaluateExpression).apply(pc)
+      case CommandLineBinding(_, _, _, _, _, Some(Inr(Inl(string: String))), Some(false)) =>
+        WdlString(string)
+      case _ => ???
+    }
+
+    wdlValue.valueString
+  }
+}
+
diff --git a/cwl/src/main/scala/cwl/CwlFile.scala b/cwl/src/main/scala/cwl/CwlFile.scala
index 5466cd6..e418fa3 100644
--- a/cwl/src/main/scala/cwl/CwlFile.scala
+++ b/cwl/src/main/scala/cwl/CwlFile.scala
@@ -117,20 +117,21 @@ case class CommandLineTool private(
       secondaryFiles
      */
 
+    val inputNames = this.inputs.map(_.id).toSet
 
     val outputs: List[Callable.OutputDefinition] = this.outputs.map {
       case CommandOutputParameter(id, _, _, _, _, _, Some(outputBinding), Some(tpe)) if tpe.select[CwlType].filter(_ == CwlType.File).isDefined =>
-        OutputDefinition(RunId(id).variableId, WdlFileType, CommandOutputExpression(outputBinding, WdlFileType))
+        OutputDefinition(FullyQualifiedName(id).id, WdlFileType, CommandOutputExpression(outputBinding, WdlFileType, inputNames))
       case CommandOutputParameter(id, _, _, _, _, _, Some(outputBinding), Some(tpe)) =>
         val wdlType = tpe.select[CwlType].map(cwlTypeToWdlType).get //<-- here be `get` dragons
-        OutputDefinition(RunId(id).variableId, wdlType, CommandOutputExpression(outputBinding, wdlType))
+        OutputDefinition(FullyQualifiedName(id).id, wdlType, CommandOutputExpression(outputBinding, wdlType, inputNames))
     }.toList
 
     val inputs: List[_ <: Callable.InputDefinition] =
       this.inputs.map { cip =>
         val tpe = cip.`type`.flatMap(_.select[CwlType]).map(cwlTypeToWdlType).get
 
-        RequiredInputDefinition(RunId(cip.id).variableId, tpe)
+        RequiredInputDefinition(FullyQualifiedName(cip.id).id, tpe)
       }.toList
 
     TaskDefinition(
diff --git a/cwl/src/main/scala/cwl/CwlWomExpression.scala b/cwl/src/main/scala/cwl/CwlWomExpression.scala
index c8ffbc3..38fcdaf 100644
--- a/cwl/src/main/scala/cwl/CwlWomExpression.scala
+++ b/cwl/src/main/scala/cwl/CwlWomExpression.scala
@@ -1,11 +1,16 @@
 package cwl
 
-import cats.syntax.validated._
+import cats.data.NonEmptyList
+import cats.data.Validated.Invalid
+import cats.syntax.option._
+import cwl.WorkflowStepInput.InputSource
 import lenthall.validation.ErrorOr.ErrorOr
 import lenthall.validation.Validation._
+import shapeless.{Inl, Poly1}
 import wdl.types._
 import wdl.values.{WdlArray, WdlFile, WdlGlobFile, WdlMap, WdlString, WdlValue}
 import wom.expression.{IoFunctionSet, WomExpression}
+import cats.syntax.validated._
 
 sealed trait CwlWomExpression extends WomExpression {
 
@@ -15,37 +20,67 @@ sealed trait CwlWomExpression extends WomExpression {
 }
 
 case class CommandOutputExpression(outputBinding: CommandOutputBinding,
-                                   override val cwlExpressionType: WdlType) extends CwlWomExpression {
+                                   override val cwlExpressionType: WdlType,
+                                   override val inputs: Set[String]) extends CwlWomExpression {
 
   // TODO WOM: outputBinding.toString is probably not be the best representation of the outputBinding
   override def sourceString = outputBinding.toString
   override def evaluateValue(inputValues: Map[String, WdlValue], ioFunctionSet: IoFunctionSet): ErrorOr[WdlValue] = {
     val parameterContext = ParameterContext.Empty.withInputs(inputValues, ioFunctionSet)
 
-    val wdlValue = outputBinding.commandOutputBindingToWdlValue(parameterContext, ioFunctionSet)
-    cwlExpressionType.coerceRawValue(wdlValue).toErrorOr
+    val wdlValue: WdlValue = outputBinding.commandOutputBindingToWdlValue(parameterContext, ioFunctionSet)
+    val extractFile: WdlValue =
+      wdlValue match {
+        case WdlArray(WdlMaybeEmptyArrayType(WdlMapType(WdlStringType, WdlStringType)), Seq(WdlMap(WdlMapType(WdlStringType, WdlStringType), map))) =>
+          map(WdlString("location"))
+        case other => other
+      }
+    cwlExpressionType.coerceRawValue(extractFile).toErrorOr
   }
 
-  override def inputs: Set[String] = ???
-
   /*
   TODO:
    DB: It doesn't make sense to me that this function returns type WdlFile but accepts a type to which it coerces.
    Wouldn't coerceTo always == WdlFileType, and if not then what?
    */
-  override def evaluateFiles(inputTypes: Map[String, WdlValue], ioFunctionSet: IoFunctionSet, coerceTo: WdlType): ErrorOr[Set[WdlFile]] ={
+  override def evaluateFiles(inputs: Map[String, WdlValue], ioFunctionSet: IoFunctionSet, coerceTo: WdlType): ErrorOr[Set[WdlFile]] ={
 
-    val pc = ParameterContext.Empty.withInputs(inputTypes, ioFunctionSet)
-    val wdlValue = outputBinding.commandOutputBindingToWdlValue(pc, ioFunctionSet)
+    val pc = ParameterContext.Empty.withInputs(inputs, ioFunctionSet)
 
-    wdlValue match {
+    outputBinding.glob.toList.flatMap {
+      globValue =>
+        GlobEvaluator.globPaths(globValue, pc, ioFunctionSet).toList
+    }.map{
+      s:String =>
+        WdlGlobFile(s): WdlFile
+    }.toSet.validNel[String]
+  }
+}
+
+case class WorkflowStepInputExpression(input: WorkflowStepInput, override val cwlExpressionType: WdlType, val graphInputs: Set[String]) extends CwlWomExpression {
 
-      case WdlArray(WdlMaybeEmptyArrayType(WdlMapType(WdlStringType, WdlStringType)), seq: Seq[WdlValue]) =>
-        seq.map {
-          case WdlMap(WdlMapType(WdlStringType, WdlStringType), map) => WdlGlobFile(map(WdlString("location")).valueString): WdlFile
-        }.toSet.validNel
+  override def sourceString = input.toString
 
-      case other =>s":( we saw $other and couldn't convert to a globfile type: ${other.wdlType} coerceTo: $coerceTo".invalidNel[Set[WdlFile]]
+  override def evaluateValue(inputValues: Map[String, WdlValue], ioFunctionSet: IoFunctionSet) = {
+    (input.valueFrom, input.source) match {
+      case (None, Some(Inl(id: String))) =>
+        inputValues.
+          get(FullyQualifiedName(id).id).
+          toValidNel(s"could not find id $id in typeMap\n${inputValues.mkString("\n")}\nwhen evaluating $input.  Graph Inputs were ${graphInputs.mkString("\n")}")
+      case _ => Invalid(NonEmptyList.one("could not decipher evaluateValue, most likely has not been implemented yet"))
     }
   }
+
+  override def evaluateFiles(inputTypes: Map[String, WdlValue], ioFunctionSet: IoFunctionSet, coerceTo: WdlType) = ???
+
+  object InputSourceToFileNames extends Poly1{
+
+    implicit def string = at[String]{s => Set(FullyQualifiedName(s).id)}
+
+    implicit def array = at[Array[String]]{_.map(FullyQualifiedName(_).id).toSet}
+  }
+
+  override def inputs = graphInputs ++ input.source.toSet.flatMap{(_:InputSource).fold(InputSourceToFileNames)}
 }
+
+
diff --git a/cwl/src/main/scala/cwl/FullyQualifiedName.scala b/cwl/src/main/scala/cwl/FullyQualifiedName.scala
index 071cdac..20a6572 100644
--- a/cwl/src/main/scala/cwl/FullyQualifiedName.scala
+++ b/cwl/src/main/scala/cwl/FullyQualifiedName.scala
@@ -10,78 +10,45 @@ package cwl
   */
 trait FullyQualifiedName {
   val fileName: String
+  val id: String
 }
 
-case class WorkflowInputId private (fileName: String, inputId: String) extends FullyQualifiedName
+case class FileAndId private(fileName: String, id: String) extends FullyQualifiedName
 
-object WorkflowInputId {
-  def apply(in: String): WorkflowInputId = {
+object FileAndId {
+  def apply(in: String): FileAndId = {
     val Array(fileName, id) = in.split("#")
 
-    WorkflowInputId(fileName, id)
+    FileAndId(fileName, id)
   }
 }
 
-case class WorkflowOutputId private (fileName: String, stepId: String, outputId: String) extends FullyQualifiedName
+case class FileStepAndId private(fileName: String, stepId: String, id: String) extends FullyQualifiedName
 
-object WorkflowOutputId {
-  def apply(in: String): WorkflowOutputId = {
+object FileStepAndId {
+  def apply(in: String): FileStepAndId = {
     val Array(fileName, id) = in.split("#")
     val Array(stepId, outputId) = id.split("/")
 
-    WorkflowOutputId(fileName, stepId, outputId)
+    FileStepAndId(fileName, stepId, outputId)
   }
 }
 
-case class WorkflowStepId private (fileName: String, stepId: String) extends FullyQualifiedName
+case class FileStepUUID(fileName: String, id: String, uuid: String, stepId: String) extends FullyQualifiedName
 
-object WorkflowStepId {
-  def apply(in: String): WorkflowStepId = {
-    val Array(fileName, id) = in.split("#")
-
-    WorkflowStepId(fileName, id)
-  }
-}
-
-case class WorkflowStepInputOrOutputId private(fileName: String, stepId: String, ioId: String) extends FullyQualifiedName
-
-object WorkflowStepInputOrOutputId {
-  def apply(in: String): WorkflowStepInputOrOutputId = {
-    val Array(fileName, id) = in.split("#")
-    val Array(stepId, fieldId) = id.split("/")
-
-    WorkflowStepInputOrOutputId(fileName, stepId, fieldId)
-  }
-}
-
-sealed trait RunId {
-  def fileName: String
-  def variableId: String
-}
-
-case class SameFileRunOutputId(fileName: String, variableId: String, uuid: String, stepId: String) extends RunId
-
-case class DifferentFileRunOutputId(fileName: String, variableId: String) extends RunId
-
-object RunId {
-  def apply(in: String): RunId = {
-    val Array(fileName, stepAndid) = in.split("#")
-
-    if (stepAndid.contains("/")) {
-      val Array(step, uuid, id) = stepAndid.split("/")
-      SameFileRunOutputId(fileName, id, uuid, step)
-    } else
-      DifferentFileRunOutputId(fileName, stepAndid)
-  }
-}
 object FullyQualifiedName {
   def apply(in: String): FullyQualifiedName = {
 
-   val Array(_, after) = in.split("#")
+     in.split("#") match {
+       case Array(file, after) =>
+        (after.split("/").toList) match {
+          case step :: uuid :: id :: Nil => FileStepUUID(file, id, uuid, step)
+          case step :: id :: Nil => FileStepAndId(file, step, id)
+          case id :: Nil => FileAndId(file, id)
+          case _ => throw new RuntimeException(s"malformed FQN: $in")
+        }
+       case _ => throw new RuntimeException(s"malformed FQN: $in")
+     }
 
-   if (after.contains("/"))
-     WorkflowStepInputOrOutputId(in)
-    else
-     WorkflowInputId(in)
   }
 }
diff --git a/cwl/src/main/scala/cwl/ParameterContext.scala b/cwl/src/main/scala/cwl/ParameterContext.scala
index 123ae82..cc994af 100644
--- a/cwl/src/main/scala/cwl/ParameterContext.scala
+++ b/cwl/src/main/scala/cwl/ParameterContext.scala
@@ -14,12 +14,15 @@ object ParameterContext {
 
 case class ParameterContext(inputs: WdlValue, self: WdlValue, runtime: WdlValue) {
   def withInputs(inputValues: Map[String, WdlValue], ioFunctionSet: IoFunctionSet): ParameterContext = {
-    val wdlValueType = inputValues.values.headOption.map(_.wdlType).getOrElse(WdlNothingType)
+    val wdlValueType = WdlStringType
     copy(
       inputs = WdlMap(
         WdlMapType(WdlStringType, wdlValueType),
         // TODO: WOM: convert inputValues (including WdlFile?) to inputs using the ioFunctionSet
-        inputValues map { case (name, wdlValue) => WdlString(name) -> wdlValue }
+        inputValues map {
+          case (name, WdlSingleFile(path)) => WdlString(name) -> WdlString(path)
+          case (name, wdlValue) => WdlString(name) -> wdlValue
+        }
       )
     )
   }
diff --git a/cwl/src/main/scala/cwl/Workflow.scala b/cwl/src/main/scala/cwl/Workflow.scala
index ede7f45..7d8fd2a 100644
--- a/cwl/src/main/scala/cwl/Workflow.scala
+++ b/cwl/src/main/scala/cwl/Workflow.scala
@@ -58,12 +58,12 @@ case class Workflow private(
     val graphFromInputs: Set[ExternalGraphInputNode] = inputs.map {
       // TODO WOM: need to be able to transform this default value to a WomExpression
       case inputParameter if inputParameter.default.isDefined =>
-        val parsedInputId = WorkflowInputId(inputParameter.id).inputId
+        val parsedInputId = FileAndId(inputParameter.id).id
         val womType = wdlTypeForInputParameter(inputParameter).get
 
         OptionalGraphInputNodeWithDefault(WomIdentifier(parsedInputId), womType, PlaceholderWomExpression(Set.empty, womType))
       case input =>
-        val parsedInputId = WorkflowInputId(input.id).inputId
+        val parsedInputId = FileAndId(input.id).id
 
         RequiredGraphInputNode(WomIdentifier(parsedInputId), wdlTypeForInputParameter(input).get)
     }.toSet
@@ -86,16 +86,16 @@ case class Workflow private(
 
           val wdlType = cwlTypeToWdlType(output.`type`.flatMap(_.select[CwlType]).get)
 
-          def lookupOutputSource(outputId: WorkflowOutputId): Checked[OutputPort] =
+          def lookupOutputSource(outputId: FileStepAndId): Checked[OutputPort] =
             for {
               set <- graphFromSteps
               call <- set.collectFirst { case callNode: CallNode if callNode.localName == outputId.stepId => callNode }.
                 toRight(NonEmptyList.one(s"Call Node by name ${outputId.stepId} was not found in set $set"))
-              output <- call.outputPorts.find(_.name == outputId.outputId).
-                          toRight(NonEmptyList.one(s"looking for ${outputId.outputId} in call $call output ports ${call.outputPorts}"))
+              output <- call.outputPorts.find(_.name == outputId.id).
+                          toRight(NonEmptyList.one(s"looking for ${outputId.id} in call $call output ports ${call.outputPorts}"))
             } yield output
 
-          lookupOutputSource(WorkflowOutputId(output.outputSource.flatMap(_.select[String]).get)).
+          lookupOutputSource(FileStepAndId(output.outputSource.flatMap(_.select[String]).get)).
             map(PortBasedGraphOutputNode(WomIdentifier(output.id), wdlType, _)).toValidated
       }.map(_.toSet).toEither
 
diff --git a/cwl/src/main/scala/cwl/WorkflowOutputsToOutputDefinition.scala b/cwl/src/main/scala/cwl/WorkflowOutputsToOutputDefinition.scala
index 2ac3aa4..14708c8 100644
--- a/cwl/src/main/scala/cwl/WorkflowOutputsToOutputDefinition.scala
+++ b/cwl/src/main/scala/cwl/WorkflowOutputsToOutputDefinition.scala
@@ -2,26 +2,26 @@ package cwl
 
 import shapeless.Poly1
 import wom.callable.Callable.OutputDefinition
-import wom.expression.PlaceholderWomExpression
+import wom.expression.WomExpression
 
 object WorkflowOutputsToOutputDefinition extends Poly1 {
 
-  def fullIdToOutputDefintition(fullyQualifiedName: String, typeMap: WdlTypeMap) = {
+  def fullIdToOutputDefintition(fullyQualifiedName: String, typeMap: WdlTypeMap, expression: Map[String, WomExpression]) = {
 
     //we want to only look at the id, not the filename
-    val lookupId = WorkflowStepInputOrOutputId(fullyQualifiedName).ioId
+    val lookupId = FullyQualifiedName(fullyQualifiedName).id
 
-    OutputDefinition(fullyQualifiedName, typeMap(lookupId), PlaceholderWomExpression(Set.empty, typeMap(lookupId)))
+    OutputDefinition(fullyQualifiedName, typeMap(lookupId), expression(lookupId))
   }
 
   implicit def a = at[Array[WorkflowStepOutput]] { outputs =>
-    (typeMap: WdlTypeMap) =>
-      outputs.map(output => fullIdToOutputDefintition(output.id, typeMap)).toSet
+    (typeMap: WdlTypeMap, expressionMap: Map[String, WomExpression]) =>
+      outputs.map(output => fullIdToOutputDefintition(output.id, typeMap, expressionMap)).toSet
   }
 
   implicit def b = at[Array[String]] { outputs =>
-    (typeMap: WdlTypeMap) =>
-      outputs.map(fullIdToOutputDefintition(_, typeMap)).toSet
+    (typeMap: WdlTypeMap, expressionMap: Map[String, WomExpression]) =>
+      outputs.map(fullIdToOutputDefintition(_, typeMap, expressionMap)).toSet
   }
 
 }
diff --git a/cwl/src/main/scala/cwl/WorkflowStep.scala b/cwl/src/main/scala/cwl/WorkflowStep.scala
index b6ab7a1..08a9f9d 100644
--- a/cwl/src/main/scala/cwl/WorkflowStep.scala
+++ b/cwl/src/main/scala/cwl/WorkflowStep.scala
@@ -14,10 +14,8 @@ import lenthall.validation.ErrorOr.ErrorOr
 import shapeless._
 import cwl.ScatterMethod._
 import cwl.WorkflowStep._
-import wdl.types.WdlAnyType
 import wdl.values.WdlValue
 import wom.callable.Callable._
-import wom.expression.PlaceholderWomExpression
 import wom.graph.CallNode._
 import wom.graph.GraphNodePort.{GraphNodeOutputPort, OutputPort}
 import wom.graph._
@@ -48,7 +46,7 @@ case class WorkflowStep(
 
   def fileName: Option[String] = run.select[String]
 
-  val unqualifiedStepId = WomIdentifier(Try(WorkflowStepId(id)).map(_.stepId).getOrElse(id))
+  val unqualifiedStepId = WomIdentifier(Try(FullyQualifiedName(id)).map(_.id).getOrElse(id))
 
   /**
     * Generates all GraphNodes necessary to represent call nodes and input nodes
@@ -86,7 +84,6 @@ case class WorkflowStep(
           val inputSource: String = workflowStepInput.source.flatMap(_.select[String]).get
 
           // Name of the step input
-          val stepInputName = WorkflowStepInputOrOutputId(workflowStepInput.id).ioId
 
           val accumulatedNodes = fold.generatedNodes ++ knownNodes
 
@@ -112,7 +109,7 @@ case class WorkflowStep(
           def buildUpstreamNodes(upstreamStepId: String): Checked[Set[GraphNode]] =
           // Find the step corresponding to this upstreamStepId in the set of all the steps of this workflow
             for {
-              step <- workflow.steps.find { step => WorkflowStepId(step.id).stepId == upstreamStepId }.
+              step <- workflow.steps.find { step => FullyQualifiedName(step.id).id == upstreamStepId }.
                 toRight(NonEmptyList.one(s"no step of id $upstreamStepId found in ${workflow.steps.map(_.id)}"))
               call <- step.callWithInputs(typeMap, workflow, accumulatedNodes, workflowInputs)
             } yield call
@@ -139,9 +136,9 @@ case class WorkflowStep(
 
           def updateFold(outputPort: OutputPort, newCallNodes: Set[GraphNode] = Set.empty): Checked[WorkflowStepInputFold] = {
             // TODO for now we only handle a single input source, but there may be several
-            workflowStepInput.toExpressionNode(Map(inputSource -> outputPort)).map({ expressionNode =>
+            workflowStepInput.toExpressionNode(Map(FullyQualifiedName(inputSource).id -> outputPort) ++ workflowInputs, typeMap, workflowInputs.keySet).map({ expressionNode =>
               fold |+| WorkflowStepInputFold(
-                stepInputMapping = Map(stepInputName -> expressionNode),
+                stepInputMapping = Map(FullyQualifiedName(workflowStepInput.id).id -> expressionNode),
                 generatedNodes = newCallNodes + expressionNode
               )
             }).toEither
@@ -155,9 +152,9 @@ case class WorkflowStep(
            */
           FullyQualifiedName(inputSource) match {
             // The source points to a workflow input, which means it should be in the workflowInputs map
-            case WorkflowInputId(_, inputId) => fromWorkflowInput(inputId)
+            case FileAndId(_, inputId) => fromWorkflowInput(inputId)
             // The source points to an output from a different step
-            case WorkflowStepInputOrOutputId(_, stepId, stepOutputId) => fromStepOutput(stepId, stepOutputId)
+            case FileStepAndId(_, stepId, stepOutputId) => fromStepOutput(stepId, stepOutputId)
           }
       }
 
@@ -243,14 +240,6 @@ object WorkflowStep {
 
   val emptyOutputs: Outputs = Coproduct[Outputs](Array.empty[String])
 
-  implicit class EnhancedWorkflowStepInput(val workflowStepInput: WorkflowStepInput) extends AnyVal {
-    def toExpressionNode(sourceMappings: Map[String, OutputPort]): ErrorOr[ExpressionNode] = {
-      val womExpression = PlaceholderWomExpression(sourceMappings.keySet, WdlAnyType)
-      val identifier = WomIdentifier(workflowStepInput.id)
-      ExpressionNode.linkWithInputs(identifier, womExpression, sourceMappings)
-    }
-  }
-
   object InputSourcesFold extends Poly1 {
     implicit def one: Case.Aux[String, Set[String]] = at[String] { Set(_) }
     implicit def many: Case.Aux[Array[String], Set[String]] = at[Array[String]] { _.toSet }
diff --git a/cwl/src/main/scala/cwl/model.scala b/cwl/src/main/scala/cwl/model.scala
index e347f0b..07da4e6 100644
--- a/cwl/src/main/scala/cwl/model.scala
+++ b/cwl/src/main/scala/cwl/model.scala
@@ -1,17 +1,43 @@
 package cwl
 
+import cats.data.NonEmptyList
 import eu.timepit.refined._
+import cats.syntax.either._
 import shapeless.{:+:, CNil, Witness}
 import shapeless.syntax.singleton._
 import cwl.LinkMergeMethod.LinkMergeMethod
 import cwl.WorkflowStepInput.InputSource
+import lenthall.validation.ErrorOr.ErrorOr
+import wdl.types.WdlType
+import wom.graph.{ExpressionNode, WomIdentifier}
+import wom.graph.GraphNodePort.OutputPort
 
 case class WorkflowStepInput(
   id: String,
   source: Option[InputSource] = None,
   linkMerge: Option[LinkMergeMethod] = None,
   default: Option[CwlAny] = None,
-  valueFrom: Option[StringOrExpression] = None)
+  valueFrom: Option[StringOrExpression] = None) {
+
+  def toExpressionNode(sourceMappings: Map[String, OutputPort],
+                       outputTypeMap: Map[String, WdlType],
+                       inputs: Set[String]
+                      ): ErrorOr[ExpressionNode] = {
+    val source = this.source.flatMap(_.select[String]).get
+    val lookupId = FullyQualifiedName(source).id
+
+    val outputTypeMapWithIDs = outputTypeMap.map {
+      case (key, value) => FullyQualifiedName(key).id -> value
+    }
+    (for {
+      tpe <- outputTypeMapWithIDs.get(lookupId).
+        toRight(NonEmptyList.one(s"couldn't find $lookupId as derived from $source in map\n${outputTypeMapWithIDs.mkString("\n")}"))
+      womExpression = WorkflowStepInputExpression(this, tpe, inputs)
+      identifier = WomIdentifier(id)
+      ret <- ExpressionNode.linkWithInputs(identifier, womExpression, sourceMappings).toEither
+    } yield ret).toValidated
+  }
+}
 
 object WorkflowStepInput {
   type InputSource = String :+: Array[String] :+: CNil
diff --git a/cwl/src/test/resources/three_step.cwl b/cwl/src/test/resources/three_step.cwl
index 5c46e21..5731df2 100644
--- a/cwl/src/test/resources/three_step.cwl
+++ b/cwl/src/test/resources/three_step.cwl
@@ -1,47 +1,46 @@
 cwlVersion: v1.0
 class: Workflow
 inputs:
-- id: file:///Users/danb/wdl4s/r.cwl#pattern
+- id: pattern
   type: string
 outputs:
-- id: file:///Users/danb/wdl4s/r.cwl#cgrep-count
-  outputSource: file:///Users/danb/wdl4s/r.cwl#cgrep/cgrep-count
+- id: cgrep-count
+  outputSource: "#cgrep/cgrep-count"
   type: int
-- id: file:///Users/danb/wdl4s/r.cwl#wc-count
-  outputSource: file:///Users/danb/wdl4s/r.cwl#wc/wc-count
+- id: wc-count
+  outputSource: "#wc/wc-count"
   type: int
 steps:
-- id: file:///Users/danb/wdl4s/r.cwl#ps
+- id: ps
   in: []
   out:
-  - file:///Users/danb/wdl4s/r.cwl#ps/ps-stdOut
+  - id: ps-stdOut
   run:
     inputs: []
     outputs:
-    - id: file:///Users/danb/wdl4s/r.cwl#ps/0b4ba500-5584-4fed-a831-9fa6f914ad3f/ps-stdOut
+    - id: ps-stdOut
       outputBinding:
         glob: ps-stdOut.txt
       type: File
     class: CommandLineTool
     baseCommand: ps
     stdout: ps-stdOut.txt
-    id: file:///Users/danb/wdl4s/r.cwl#ps/0b4ba500-5584-4fed-a831-9fa6f914ad3f
-- id: file:///Users/danb/wdl4s/r.cwl#cgrep
+- id: cgrep
   in:
-  - id: file:///Users/danb/wdl4s/r.cwl#cgrep/pattern
-    source: file:///Users/danb/wdl4s/r.cwl#pattern
-  - id: file:///Users/danb/wdl4s/r.cwl#cgrep/file
-    source: file:///Users/danb/wdl4s/r.cwl#ps/ps-stdOut
+  - id: pattern
+    source: "#pattern"
+  - id: file
+    source: "#ps/ps-stdOut"
   out:
-  - id: file:///Users/danb/wdl4s/r.cwl#cgrep/cgrep-count
+  - id: cgrep-count
   run:
     inputs:
-    - id: file:///Users/danb/wdl4s/r.cwl#cgrep/09f8bcac-a91a-49d5-afb6-2f1b1294e875/pattern
+    - id: pattern
       type: string
-    - id: file:///Users/danb/wdl4s/r.cwl#cgrep/09f8bcac-a91a-49d5-afb6-2f1b1294e875/file
+    - id: file
       type: File
     outputs:
-    - id: file:///Users/danb/wdl4s/r.cwl#cgrep/09f8bcac-a91a-49d5-afb6-2f1b1294e875/cgrep-count
+    - id: cgrep-count
       outputBinding:
         glob: cgrep-stdOut.txt
         loadContents: true
@@ -65,19 +64,18 @@ steps:
     - valueFrom: -l
       shellQuote: false
     stdout: cgrep-stdOut.txt
-    id: file:///Users/danb/wdl4s/r.cwl#cgrep/09f8bcac-a91a-49d5-afb6-2f1b1294e875
-- id: file:///Users/danb/wdl4s/r.cwl#wc
+- id: wc
   in:
-  - id: file:///Users/danb/wdl4s/r.cwl#wc/file
-    source: file:///Users/danb/wdl4s/r.cwl#ps/ps-stdOut
+  - id: file
+    source: "#ps/ps-stdOut"
   out:
-  - id: file:///Users/danb/wdl4s/r.cwl#wc/wc-count
+  - id: wc-count
   run:
     inputs:
-    - id: file:///Users/danb/wdl4s/r.cwl#wc/45d98851-7bfe-473e-ab24-aac922553f3e/file
+    - id: file
       type: File
     outputs:
-    - id: file:///Users/danb/wdl4s/r.cwl#wc/45d98851-7bfe-473e-ab24-aac922553f3e/wc-count
+    - id: wc-count
       outputBinding:
         glob: wc-stdOut.txt
         loadContents: true
@@ -99,5 +97,3 @@ steps:
     - valueFrom: -l
       shellQuote: false
     stdout: wc-stdOut.txt
-    id: file:///Users/danb/wdl4s/r.cwl#wc/45d98851-7bfe-473e-ab24-aac922553f3e
-id: file:///Users/danb/wdl4s/r.cwl
diff --git a/cwl/src/test/scala/cwl/CommandOutputExpressionSpec.scala b/cwl/src/test/scala/cwl/CommandOutputExpressionSpec.scala
index b35f74f..5596122 100644
--- a/cwl/src/test/scala/cwl/CommandOutputExpressionSpec.scala
+++ b/cwl/src/test/scala/cwl/CommandOutputExpressionSpec.scala
@@ -11,30 +11,49 @@ import eu.timepit.refined.string.MatchesRegex
 import ExpressionEvaluator._
 import cats.data.Validated.Valid
 import wdl.types.WdlIntegerType
-import wdl.values.{WdlGlobFile, WdlInteger, WdlString}
-import wom.expression.PlaceholderIoFunctionSet
+import wdl.values.{WdlGlobFile, WdlInteger, WdlString, WdlValue}
+import wom.expression.{IoFunctionSet, PlaceholderIoFunctionSet}
+
+import scala.concurrent.Future
+import scala.util.Try
 
 class CommandOutputExpressionSpec extends FlatSpec with Matchers {
 
   behavior of "CommandOutputExpression"
 
+  def ioFunctionSet(data: String) =
+    new IoFunctionSet {
+      override def readFile(path: String) = Future.successful(data)
+
+      override def writeFile(path: String, content: String) = ???
+
+      override def stdout(params: Seq[Try[WdlValue]]) = ???
+
+      override def stderr(params: Seq[Try[WdlValue]]) = ???
+
+      override def glob(path: String, pattern: String) = ???
+
+      override def size(params: Seq[Try[WdlValue]]) = ???
+    }
+
   it should "evaluateValue" in {
-    val tempFile = better.files.File.newTemporaryFile("glob.", ".txt").write("41.1")
+    val data = "41.1"
+    val tempFile = better.files.File.newTemporaryFile("glob.", ".txt").write(data)
     val globExpression = Coproduct[Expression](refineMV[MatchesRegex[ECMAScriptExpressionWitness.T]]("$(inputs.myTempFile)"))
     val outputEvalExpression = Coproduct[Expression](refineMV[MatchesRegex[ECMAScriptExpressionWitness.T]]("$((parseInt(self[0].contents) + 1).toFixed())"))
     val glob = Coproduct[Glob](globExpression)
     val outputEval = Coproduct[StringOrExpression](outputEvalExpression)
     val outputBinding = CommandOutputBinding(Option(glob), Option(true), Option(outputEval))
-    val commandOutputExpression = CommandOutputExpression(outputBinding, WdlIntegerType)
+    val commandOutputExpression = CommandOutputExpression(outputBinding, WdlIntegerType, Set.empty)
     val inputValues = Map("myTempFile" -> WdlString(tempFile.pathAsString))
-    val result = commandOutputExpression.evaluateValue(inputValues, PlaceholderIoFunctionSet)
+    val result = commandOutputExpression.evaluateValue(inputValues, ioFunctionSet(data))
     result should be(WdlInteger(42).valid)
   }
 
   it should "figure out stdout" in {
     val glob = Coproduct[Glob]("stdout")
     val outputBinding = CommandOutputBinding(Option(glob))
-    val commandOutputExpression = CommandOutputExpression(outputBinding, WdlIntegerType)
+    val commandOutputExpression = CommandOutputExpression(outputBinding, WdlIntegerType, Set.empty)
     val result = commandOutputExpression.evaluateFiles(Map.empty, PlaceholderIoFunctionSet, WdlIntegerType)
     result shouldBe(Valid(Set(WdlGlobFile("stdout"))))
   }
diff --git a/cwl/src/test/scala/cwl/CwlWorkflowWomSpec.scala b/cwl/src/test/scala/cwl/CwlWorkflowWomSpec.scala
index 8b14c07..f288666 100644
--- a/cwl/src/test/scala/cwl/CwlWorkflowWomSpec.scala
+++ b/cwl/src/test/scala/cwl/CwlWorkflowWomSpec.scala
@@ -57,7 +57,7 @@ class CwlWorkflowWomSpec extends FlatSpec with Matchers with TableDrivenProperty
               map(_.select[Workflow].get)
 
       womDefinition <- wf.womDefinition
-    } yield validateWom(womDefinition)).leftMap(e => throw new RuntimeException(s"error! $e"))
+    } yield validateWom(womDefinition)).leftMap(e => throw new RuntimeException(s"error! ${e.toList.mkString("\n")}"))
 
     def shouldBeRequiredGraphInputNode(node: GraphNode, localName: String, wdlType: WdlType): Unit = {
       node.isInstanceOf[RequiredGraphInputNode] shouldBe true
@@ -84,16 +84,21 @@ class CwlWorkflowWomSpec extends FlatSpec with Matchers with TableDrivenProperty
             case tarParam: CallNode if tarParam.localName == s"untar" => tarParam
           }.get.
             upstream
-          
+
           untarUpstream should have size 2
           untarUpstream.collectFirst({
             case exprNode: ExpressionNode if exprNode.localName == s"file://$rootPath/1st-workflow.cwl#untar/extractfile" =>
               shouldBeRequiredGraphInputNode(exprNode.inputPorts.head.upstream.graphNode, "ex", WdlStringType)
           }).getOrElse(fail("Can't find expression node for ex"))
-          
+
           untarUpstream.collectFirst({
             case exprNode: ExpressionNode if exprNode.localName == s"file://$rootPath/1st-workflow.cwl#untar/tarfile" =>
-              shouldBeRequiredGraphInputNode(exprNode.inputPorts.head.upstream.graphNode, "inp", WdlFileType)
+              exprNode.inputPorts.map(_.upstream.graphNode).filter{
+                case rgin: RequiredGraphInputNode =>
+                  rgin.identifier == WomIdentifier("inp") &&
+                    rgin.womType == WdlFileType
+
+              }.size  shouldBe 1
           }).getOrElse(fail("Can't find expression node for inp"))
 
           val compileUpstreamExpressionPort = nodes.collectFirst {
@@ -101,7 +106,7 @@ class CwlWorkflowWomSpec extends FlatSpec with Matchers with TableDrivenProperty
           }.get.inputPorts.map(_.upstream).head
 
           compileUpstreamExpressionPort.name shouldBe s"file://$rootPath/1st-workflow.cwl#compile/src"
-          compileUpstreamExpressionPort.graphNode.asInstanceOf[ExpressionNode].inputPorts.head.upstream.name shouldBe s"example_out"
+          compileUpstreamExpressionPort.graphNode.asInstanceOf[ExpressionNode].inputPorts.map(_.upstream.name).filter(_ == "example_out").size shouldBe 1
 
           nodes.collect {
             case c: PortBasedGraphOutputNode => c
@@ -170,19 +175,21 @@ class CwlWorkflowWomSpec extends FlatSpec with Matchers with TableDrivenProperty
     val patternInputNode = graphInputNodes.head
     patternInputNode.localName should be("pattern")
 
-    nodes collect { case gon: GraphOutputNode => gon.localName } should be(Set(
-      "file:///Users/danb/wdl4s/r.cwl#cgrep-count",
-      "file:///Users/danb/wdl4s/r.cwl#wc-count"
+    nodes collect { case gon: GraphOutputNode => FullyQualifiedName(gon.localName).id } should be(Set(
+      "cgrep-count",
+      "wc-count"
     ))
 
     nodes collect { case cn: CallNode => cn.localName } should be(Set("ps", "cgrep", "wc"))
 
+    //def stepAndId(in: String) = s"${FileStepAndId(in).stepId}/${FileStepAndId(in).id}"
+
     val ps = nodes.collectFirst({ case ps: CallNode if ps.localName == "ps" => ps }).get
     val cgrep = nodes.collectFirst({ case cgrep: CallNode if cgrep.localName == "cgrep" => cgrep }).get
-    val cgrepFileExpression = nodes.collectFirst({ case cgrepInput: ExpressionNode if cgrepInput.localName == "file:///Users/danb/wdl4s/r.cwl#cgrep/file" => cgrepInput }).get
-    val cgrepPatternExpression = nodes.collectFirst({ case cgrepInput: ExpressionNode if cgrepInput.localName == "file:///Users/danb/wdl4s/r.cwl#cgrep/pattern" => cgrepInput }).get
+    val cgrepFileExpression = nodes.collectFirst({ case cgrepInput: ExpressionNode if s"${FileStepAndId(cgrepInput.localName).stepId}/${FileStepAndId(cgrepInput.localName).id}" == "cgrep/file" => cgrepInput }).get
+    val cgrepPatternExpression = nodes.collectFirst({ case cgrepInput: ExpressionNode if s"${FileStepAndId(cgrepInput.localName).stepId}/${FileStepAndId(cgrepInput.localName).id}" == "cgrep/pattern" => cgrepInput }).get
     val wc = nodes.collectFirst({ case wc: CallNode if wc.localName == "wc" => wc }).get
-    val wcFileExpression = nodes.collectFirst({ case wcInput: ExpressionNode if wcInput.localName == "file:///Users/danb/wdl4s/r.cwl#wc/file" => wcInput }).get
+    val wcFileExpression = nodes.collectFirst({ case wcInput: ExpressionNode if s"${FileStepAndId(wcInput.localName).stepId}/${FileStepAndId(wcInput.localName).id}" == "wc/file" => wcInput }).get
 
     ps.upstream shouldBe empty
 
@@ -191,16 +198,16 @@ class CwlWorkflowWomSpec extends FlatSpec with Matchers with TableDrivenProperty
 
     // Check that expressions input ports point to the right output port
     cgrepPatternExpression.inputPorts.head.upstream should be theSameInstanceAs patternInputNode.singleOutputPort
-    cgrepFileExpression.inputPorts.head.upstream should be theSameInstanceAs ps.outputPorts.head
-    wcFileExpression.inputPorts.head.upstream should be theSameInstanceAs ps.outputPorts.head
-    
+    cgrepFileExpression.inputPorts.map(_.upstream).filter(_ eq ps.outputPorts.head).size shouldBe 1
+    wcFileExpression.inputPorts.map(_.upstream).filter(_ eq ps.outputPorts.head).size shouldBe 1
+
     // Check that the inputDefinitionMappings are correct
     ps.inputDefinitionMappings shouldBe empty
     cgrep.inputDefinitionMappings should have size 2
-    
+
     val cgrepFileInputDef = cgrep.callable.inputs.find(_.name == "file").get
     cgrep.inputDefinitionMappings(cgrepFileInputDef).select[OutputPort].get should be theSameInstanceAs cgrepFileExpression.singleExpressionOutputPort
-    
+
     val cgrepPatternInputDef = cgrep.callable.inputs.find(_.name == "pattern").get
     cgrep.inputDefinitionMappings(cgrepPatternInputDef).select[OutputPort].get should be theSameInstanceAs cgrepPatternExpression.singleExpressionOutputPort
   }
diff --git a/cwl/src/test/scala/cwl/FullyQualifiedNameSpec.scala b/cwl/src/test/scala/cwl/FullyQualifiedNameSpec.scala
index ff53d4d..3be9674 100644
--- a/cwl/src/test/scala/cwl/FullyQualifiedNameSpec.scala
+++ b/cwl/src/test/scala/cwl/FullyQualifiedNameSpec.scala
@@ -5,17 +5,17 @@ import org.scalatest.{FlatSpec, Matchers}
 class FullyQualifiedNameSpec extends FlatSpec with Matchers {
 
   "workflow input id " should "get filename and id" in {
-    val wfid = WorkflowInputId("file#id")
+    val wfid = FileAndId("file#id")
 
     wfid.fileName shouldBe "file"
-    wfid.inputId shouldBe "id"
+    wfid.id shouldBe "id"
   }
 
   "workflow step output id " should "get filename, id, and step" in {
-    val wfid = WorkflowStepInputOrOutputId("file#step/id")
+    val wfid = FileStepAndId("file#step/id")
 
     wfid.fileName shouldBe "file"
-    wfid.ioId shouldBe "id"
+    wfid.id shouldBe "id"
     wfid.stepId shouldBe "step"
   }
 }
diff --git a/engine/src/main/scala/cromwell/engine/workflow/lifecycle/MaterializeWorkflowDescriptorActor.scala b/engine/src/main/scala/cromwell/engine/workflow/lifecycle/MaterializeWorkflowDescriptorActor.scala
index ad3b4da..fa31186 100644
--- a/engine/src/main/scala/cromwell/engine/workflow/lifecycle/MaterializeWorkflowDescriptorActor.scala
+++ b/engine/src/main/scala/cromwell/engine/workflow/lifecycle/MaterializeWorkflowDescriptorActor.scala
@@ -5,13 +5,14 @@ import akka.pattern.pipe
 import cats.Monad
 import cats.data.NonEmptyList
 import cats.data.EitherT._
-import cats.data.Validated.{Valid, Invalid}
+import cats.data.Validated.{Invalid, Valid}
 import cats.syntax.either._
 import cats.effect.IO
 import cats.instances.vector._
 import cats.syntax.apply._
 import cats.syntax.traverse._
 import cats.syntax.validated._
+import cats.syntax.either._
 import com.typesafe.config.Config
 import com.typesafe.scalalogging.LazyLogging
 import cromwell.backend.BackendWorkflowDescriptor
@@ -156,7 +157,10 @@ class MaterializeWorkflowDescriptorActor(serviceRegistryActor: ActorRef,
       workflowOptionsAndPathBuilders(workflowSourceFiles) match {
         case Valid((workflowOptions, pathBuilders)) =>
           val futureDescriptor: Future[ErrorOr[EngineWorkflowDescriptor]] = pathBuilders flatMap {
-            buildWorkflowDescriptor(workflowIdForLogging, workflowSourceFiles, conf, workflowOptions, _).value.unsafeToFuture().map(_.toValidated)
+            buildWorkflowDescriptor(workflowIdForLogging, workflowSourceFiles, conf, workflowOptions, _).
+              value.
+              unsafeToFuture().
+              map(_.toValidated)
           }
 
           // Pipe the response to self, but make it look like it comes from the sender of the command
@@ -180,7 +184,7 @@ class MaterializeWorkflowDescriptorActor(serviceRegistryActor: ActorRef,
       workflowInitializationFailed(error, sender())
       goto(MaterializationFailedState)
     case Event(Status.Failure(failure), _) =>
-      workflowInitializationFailed(NonEmptyList.of(failure.getMessage), sender())
+      workflowInitializationFailed(NonEmptyList.of(failure.getMessage, failure.getStackTrace.map(_.toString):_*), sender())
       goto(MaterializationFailedState)
   }
 
diff --git a/engine/src/main/scala/cromwell/engine/workflow/lifecycle/execution/WorkflowExecutionActor.scala b/engine/src/main/scala/cromwell/engine/workflow/lifecycle/execution/WorkflowExecutionActor.scala
index 331f99c..e8f4106 100644
--- a/engine/src/main/scala/cromwell/engine/workflow/lifecycle/execution/WorkflowExecutionActor.scala
+++ b/engine/src/main/scala/cromwell/engine/workflow/lifecycle/execution/WorkflowExecutionActor.scala
@@ -279,7 +279,7 @@ case class WorkflowExecutionActor(workflowDescriptor: EngineWorkflowDescriptor,
     import cromwell.util.JsonFormatting.WdlValueJsonFormatter._
     import spray.json._
     import WorkflowExecutionActor.EnhancedWorkflowOutputs
-    
+
     def handleSuccessfulWorkflowOutputs(outputs: Map[WomIdentifier, WdlValue]) = {
       val fullyQualifiedOutputs = outputs map {
         case (identifier, value) => identifier.fullyQualifiedName.value -> value
@@ -290,7 +290,7 @@ case class WorkflowExecutionActor(workflowDescriptor: EngineWorkflowDescriptor,
            |${fullyQualifiedOutputs.stripLarge.toJson.prettyPrint}""".stripMargin
       )
       pushWorkflowOutputMetadata(fullyQualifiedOutputs)
-      
+
       // Use local names so they can be used in outer workfows if this is a sub workflow
       val localOutputs = outputs map {
         case (identifier, value) => identifier.localName.value -> JobOutput(value)
@@ -302,8 +302,8 @@ case class WorkflowExecutionActor(workflowDescriptor: EngineWorkflowDescriptor,
 
     workflowDescriptor.namespace.innerGraph.outputNodes
       .flatMap(_.outputPorts)
-      .map(op => op.identifier -> data.outputStore.get(op, None)).toList  
-      .traverse[ErrorOr, (WomIdentifier, WdlValue)]({  
+      .map(op => op.identifier -> data.outputStore.get(op, None)).toList
+      .traverse[ErrorOr, (WomIdentifier, WdlValue)]({
         case (name, Some(value)) => (name -> value).validNel
         case (name, None) => s"Cannot find an output value for ${name.fullyQualifiedName.value}".invalidNel
       }).map(validOutputs => handleSuccessfulWorkflowOutputs(validOutputs.toMap))
@@ -314,7 +314,7 @@ case class WorkflowExecutionActor(workflowDescriptor: EngineWorkflowDescriptor,
       }
       context.parent ! WorkflowExecutionFailedResponse(data.jobExecutionMap, exception)
       goto(WorkflowExecutionFailedState)
-    }  
+    }
   }
 
   private def handleRetryableFailure(jobKey: BackendJobDescriptorKey, reason: Throwable, returnCode: Option[Int]) = {
@@ -460,7 +460,8 @@ case class WorkflowExecutionActor(workflowDescriptor: EngineWorkflowDescriptor,
     expression.upstreamPorts.traverseValues(resolve(expression, data)) map { lookup =>
       expression.evaluate(lookup, data.expressionLanguageFunctions) match {
         case Valid(result) => self ! ExpressionEvaluationSucceededResponse(expression, result)
-        case Invalid(f) => self ! ExpressionEvaluationFailedResponse(expression, new RuntimeException(f.toList.mkString(", ")))
+        case Invalid(f) =>
+          self ! ExpressionEvaluationFailedResponse(expression, new RuntimeException(f.toList.mkString(", ")))
       }
     } valueOr { f =>
       self ! ExpressionEvaluationFailedResponse(expression, new RuntimeException(f.toList.mkString(", ")))
@@ -792,11 +793,11 @@ object WorkflowExecutionActor {
 
     override val attempt = 1
     override lazy val tag = s"Expression-${node.localName}:${index.fromIndex}:$attempt"
-    
+
     protected def instantiatedExpression: InstantiatedExpression
     def womType: WdlType
     def singleOutputPort: OutputPort
-    
+
     private lazy val inputs: Map[String, InputPort] = instantiatedExpression.inputMapping
     lazy val upstreamPorts: Map[String, OutputPort] = inputs map {
       case (key, input) => key -> input.upstream
diff --git a/wom/src/main/scala/wdl/util/JsUtil.scala b/wom/src/main/scala/wdl/util/JsUtil.scala
index 9a98aed..632c87f 100644
--- a/wom/src/main/scala/wdl/util/JsUtil.scala
+++ b/wom/src/main/scala/wdl/util/JsUtil.scala
@@ -4,7 +4,7 @@ import javax.script.{ScriptContext, SimpleScriptContext}
 
 import jdk.nashorn.api.scripting.{ClassFilter, NashornScriptEngineFactory, ScriptObjectMirror}
 import wdl.types.{WdlArrayType, WdlMapType, WdlNothingType, WdlStringType}
-import wdl.values.{WdlArray, WdlBoolean, WdlFloat, WdlInteger, WdlMap, WdlOptionalValue, WdlString, WdlValue}
+import wdl.values.{WdlArray, WdlBoolean, WdlFloat, WdlInteger, WdlMap, WdlOptionalValue, WdlSingleFile, WdlString, WdlValue}
 
 import scala.collection.JavaConverters._
 
@@ -80,6 +80,7 @@ object JsUtil {
       case WdlFloat(double) => double.asInstanceOf[java.lang.Double]
       case WdlBoolean(boolean) => boolean.asInstanceOf[java.lang.Boolean]
       case WdlArray(_, array) => array.map(toJavascript).toArray
+      case WdlSingleFile(path) => path
       case WdlMap(_, map) =>
         map.map({
           case (mapKey, mapValue) => toJavascript(mapKey) -> toJavascript(mapValue)
diff --git a/wom/src/main/scala/wom/expression/WomExpression.scala b/wom/src/main/scala/wom/expression/WomExpression.scala
index c4f52bd..5652a24 100644
--- a/wom/src/main/scala/wom/expression/WomExpression.scala
+++ b/wom/src/main/scala/wom/expression/WomExpression.scala
@@ -1,9 +1,15 @@
 package wom.expression
 
-import cats.data.Validated.Valid
+import cats.data.NonEmptyList
+import cats.data.Validated.{Invalid, Valid}
 import lenthall.validation.ErrorOr.ErrorOr
 import wdl.types.WdlType
-import wdl.values.{WdlFile, WdlFloat, WdlString, WdlValue}
+import wdl.values.{WdlFile, WdlFloat, WdlValue}
+import wom.graph.{GraphNode, InstantiatedExpression}
+import wom.graph.GraphNodePort.{ConnectedInputPort, InputPort, OutputPort}
+import cats.syntax.validated._
+import cats.instances.list._
+import cats.syntax.traverse._
 
 import scala.concurrent.Future
 import scala.util.Try
@@ -14,13 +20,33 @@ trait WomExpression {
   def evaluateValue(inputValues: Map[String, WdlValue], ioFunctionSet: IoFunctionSet): ErrorOr[WdlValue]
   def evaluateType(inputTypes: Map[String, WdlType]): ErrorOr[WdlType]
   def evaluateFiles(inputTypes: Map[String, WdlValue], ioFunctionSet: IoFunctionSet, coerceTo: WdlType): ErrorOr[Set[WdlFile]]
+  def linkWithInputs(graphNodeSetter: GraphNode.GraphNodeSetter, inputMapping: Map[String, OutputPort]): ErrorOr[InstantiatedExpression] = {
+
+    def linkInput(input: String): ErrorOr[(String, InputPort)] = if (inputMapping.contains(input)) {
+      val upstreamPort = inputMapping(input)
+      Valid((input, ConnectedInputPort(input, upstreamPort.womType, upstreamPort, graphNodeSetter.get)))
+    } else {
+      s"Expression cannot be connected without the input $input (provided: ${inputMapping.toString})".invalidNel
+    }
+
+    import lenthall.validation.ErrorOr.ShortCircuitingFlatMap
+    for {
+      linkedInputList <- inputs.toList traverse linkInput
+      linkedInputs = linkedInputList.toMap
+      inputTypes = linkedInputs map { case (k, v) => k -> v.womType }
+      evaluatedType <- evaluateType(inputTypes)
+    } yield new InstantiatedExpression(this, evaluatedType, linkedInputs)
+  }
 }
 
 final case class PlaceholderWomExpression(inputs: Set[String], fixedWomType: WdlType) extends WomExpression {
   override def sourceString: String = "placeholder"
-  override def evaluateValue(inputValues: Map[String, WdlValue], ioFunctionSet: IoFunctionSet): ErrorOr[WdlValue] = Valid(WdlString("42"))
-  override def evaluateType(inputTypes: Map[String, WdlType]): ErrorOr[WdlType] = Valid(fixedWomType)
-  override def evaluateFiles(inputValues: Map[String, WdlValue], ioFunctionSet: IoFunctionSet, coerceTo: WdlType): ErrorOr[Set[WdlFile]] = Valid(Set.empty)
+  override def evaluateValue(inputValues: Map[String, WdlValue], ioFunctionSet: IoFunctionSet): ErrorOr[WdlValue] =
+    Invalid(NonEmptyList.one(s"couldn't evaluate value from inputs $inputs\tfixedWomType\t$fixedWomType\tinputValues\t$inputValues"))
+  override def evaluateType(inputTypes: Map[String, WdlType]): ErrorOr[WdlType] =
+    Valid(fixedWomType)
+  override def evaluateFiles(inputValues: Map[String, WdlValue], ioFunctionSet: IoFunctionSet, coerceTo: WdlType): ErrorOr[Set[WdlFile]] =
+    Valid(Set.empty)
 }
 
 // TODO: Flesh this out (https://github.com/broadinstitute/cromwell/issues/2521)
diff --git a/wom/src/main/scala/wom/graph/GraphNode.scala b/wom/src/main/scala/wom/graph/GraphNode.scala
index 06e2b91..72bd647 100644
--- a/wom/src/main/scala/wom/graph/GraphNode.scala
+++ b/wom/src/main/scala/wom/graph/GraphNode.scala
@@ -68,7 +68,7 @@ object GraphNode {
     * Allows a level of indirection, so that GraphNodePorts can be constructed before their associated GraphNode is
     * constructed. If used, the _graphNode must be set before anything tries to apply 'get'.
     */
-  private[graph] class GraphNodeSetter {
+  class GraphNodeSetter {
     var _graphNode: GraphNode = _
     private def getGraphNode = _graphNode
     def get: Unit => GraphNode = _ => getGraphNode
diff --git a/wom/src/main/scala/wom/graph/GraphNodeInputExpression.scala b/wom/src/main/scala/wom/graph/GraphNodeInputExpression.scala
index ad7343a..19d60f1 100644
--- a/wom/src/main/scala/wom/graph/GraphNodeInputExpression.scala
+++ b/wom/src/main/scala/wom/graph/GraphNodeInputExpression.scala
@@ -17,7 +17,7 @@ case class GraphNodeInputExpression(inputName: String, expression: WomExpression
   /**
     * Instantiate the expression and connect its input ports to the appropriate graphNode.
     */
-  private[graph] def instantiateExpression(graphNodeSetter: GraphNodeSetter): ErrorOr[InstantiatedExpression] = InstantiatedExpression.linkWithInputs(graphNodeSetter, expression, inputMapping)
+  private[graph] def instantiateExpression(graphNodeSetter: GraphNodeSetter): ErrorOr[InstantiatedExpression] = expression.linkWithInputs(graphNodeSetter, inputMapping)
 
   private[graph] lazy val evaluateType: ErrorOr[WdlType] = expression.evaluateType(inputMapping.map { case (name, port) => (name, port.womType) })
 }
diff --git a/wom/src/main/scala/wom/graph/InstantiatedExpression.scala b/wom/src/main/scala/wom/graph/InstantiatedExpression.scala
index adecadb..3498f42 100644
--- a/wom/src/main/scala/wom/graph/InstantiatedExpression.scala
+++ b/wom/src/main/scala/wom/graph/InstantiatedExpression.scala
@@ -1,15 +1,11 @@
 package wom.graph
 
-import cats.instances.list._
-import cats.syntax.traverse._
-import cats.syntax.validated._
-import cats.data.Validated.Valid
 import lenthall.validation.ErrorOr.ErrorOr
 import wdl.types.WdlType
 import wom.expression.WomExpression
-import wom.graph.GraphNodePort.{ConnectedInputPort, InputPort, OutputPort}
+import wom.graph.GraphNodePort.{InputPort, OutputPort}
 
-class InstantiatedExpression private(val expression: WomExpression, val womReturnType: WdlType, val inputMapping: Map[String, InputPort]) {
+class InstantiatedExpression (val expression: WomExpression, val womReturnType: WdlType, val inputMapping: Map[String, InputPort]) {
   val inputPorts = inputMapping.values.toSet
 }
 
@@ -19,26 +15,10 @@ object InstantiatedExpression {
     val graphNodeSetter = new GraphNode.GraphNodeSetter()
 
     for {
-      linkedInputs <- InstantiatedExpression.linkWithInputs(graphNodeSetter, expression, inputMapping)
+      linkedInputs <- expression.linkWithInputs(graphNodeSetter, inputMapping)
       expressionNode = nodeConstructor(nodeIdentifier, linkedInputs)
       _ = graphNodeSetter._graphNode = expressionNode
     } yield expressionNode
   }
 
-  def linkWithInputs(graphNodeSetter: GraphNode.GraphNodeSetter, expression: WomExpression, inputMapping: Map[String, OutputPort]): ErrorOr[InstantiatedExpression] = {
-    def linkInput(input: String): ErrorOr[(String, InputPort)] = if (inputMapping.contains(input)) {
-      val upstreamPort = inputMapping(input)
-      Valid((input, ConnectedInputPort(input, upstreamPort.womType, upstreamPort, graphNodeSetter.get)))
-    } else {
-      s"Expression cannot be connected without the input $input (provided: ${inputMapping.toString})".invalidNel
-    }
-
-    import lenthall.validation.ErrorOr.ShortCircuitingFlatMap
-    for {
-      linkedInputList <- expression.inputs.toList traverse linkInput
-      linkedInputs = linkedInputList.toMap
-      inputTypes = linkedInputs map { case (k, v) => k -> v.womType }
-      evaluatedType <- expression.evaluateType(inputTypes)
-    } yield new InstantiatedExpression(expression, evaluatedType, linkedInputs)
-  }
 }
\ No newline at end of file
