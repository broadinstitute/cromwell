package cromwell.engine.finalcall

import cromwell.backend.JobKey
import cromwell.core.OptionNotFoundException
import cromwell.engine.FullyQualifiedName
import cromwell.engine.backend.{BackendCallJobDescriptor, WorkflowDescriptor}
import cromwell.engine.db.ExecutionDatabaseKey
import cromwell.engine.workflow.BackendCallKey
import cromwell.webservice.WorkflowMetadataResponse
import wdl4s.{FullyQualifiedName => _, _}

import scala.collection.immutable.Traversable
import scala.util.{Failure, Success}

/**
  * Create a Call and return Inputs for a special Call to be run after all others in the Workflow.
  *
  * Each instance of FinalCall is used to create a separate Call per Workflow via FinalCall.createCall.
  *
  * After the workflow completes, the Call is provided CallInputs generated by createCallInputs.
  */
trait FinalCall {
  /**
    * Part of the call name. To ensure this final call name doesn't conflict with workflow tasks/calls, the full call
    * name will be created with FinalCall.callName().
    */
  def finalCallName: String

  /** The source for the task to turn into a Call. */
  def wdlSource: WdlSource

  /**
    * Creates the call inputs for this final call based on the workflow(descriptor) and the metadata produced by the
    * workflow.
    */
  def createCallInputs(workflow: WorkflowDescriptor, metadata: WorkflowMetadataResponse): CallInputs
}

object FinalCall {
  private val FinalCallPrefix = "$final_call"

  private val finalCalls: Traversable[FinalCall] = List(CopyWorkflowLogCall, CopyWorkflowOutputsCall, CopyCallLogsCall)

  def createFinalCalls(workflowDescriptor: WorkflowDescriptor): Traversable[Call] = {
    finalCalls map createCall(workflowDescriptor)
  }

  /** Return the name for a Call based on a final call name. */
  private def callName(finalCallname: String): String = "%s$%s".format(FinalCall.FinalCallPrefix, finalCallname)

  private def createCall(workflowDescriptor: WorkflowDescriptor)(finalCall: FinalCall): Call = {
    // Callers are each passing in WorkflowDescriptor, but we only need the Workflow.
    val workflow = workflowDescriptor.namespace.workflow
    val wdlAst = AstTools.getAst(finalCall.wdlSource, finalCall.finalCallName)
    val importNamespace = callName("final_calls")
    val wdlNamespace = WdlNamespace.apply(wdlAst, finalCall.wdlSource, null, Option(importNamespace))
    val task = wdlNamespace.tasks.headOption.getOrElse(
      throw new IllegalStateException(s"Did not generate a task from wdl: ${finalCall.wdlSource}"))
    // This is handled as a special case by the WorkflowActor. We don't have to list the specially here.
    val prerequisiteCallNames = Set.empty[String]
    val call = Call(None, callName(finalCall.finalCallName), task, prerequisiteCallNames, Map.empty, Option(workflow))
    call
  }

  /** Retrieve a value from the workflow options. */
  def getWorkflowOption(workflowDescriptor: WorkflowDescriptor, key: String): Option[String] = {
    workflowDescriptor.workflowOptions.get(key) match {
      case Success(value) => Option(value)
      case Failure(e: OptionNotFoundException) => None
      case Failure(e: IllegalArgumentException) =>
        workflowDescriptor.workflowLogger.warn(s"$key expected to be of type String", e)
        None
      case Failure(e) =>
        workflowDescriptor.workflowLogger.warn(s"Error looking up $key from workflow options: ${e.getMessage}", e)
        None
    }
  }

  /** Returns a file system safe version of the name. */
  def escapedFinalCallName(name: String) = name.replaceAll("\\$", "__")


  /** Return the final call with this fqn. */
  private def finalCallForFqn(fqn: FullyQualifiedName): Option[FinalCall] = {
    finalCalls.
      find(finalCall => fqn.endsWith(callName(finalCall.finalCallName)))
  }

  trait FinalCallConverter {
    protected def fullyQualifiedName: FullyQualifiedName

    /** Does this FQN conform to a final call? */
    def isFinalCall = fullyQualifiedName contains FinalCallPrefix

    /** Create a store key for this workflow(descriptor). */
    def createCall(workflowDescriptor: WorkflowDescriptor): Option[Call] = {
      finalCallForFqn(fullyQualifiedName) map FinalCall.createCall(workflowDescriptor)
    }
  }

  implicit class FinalCallDatabaseKey(val key: ExecutionDatabaseKey) extends FinalCallConverter {
    override protected val fullyQualifiedName = key.fqn
  }

  implicit class FinalCallJobKey(val key: JobKey) extends FinalCallConverter {
    override protected val fullyQualifiedName = key.scope.fullyQualifiedName
  }

  implicit class FinalCallBackendCallKey(val backendCallKey: BackendCallKey) extends FinalCallJobKey(backendCallKey) {
    /** Return a job descriptor for this final call. */
    def finalCallJobDescriptor(workflow: WorkflowDescriptor, metadata: WorkflowMetadataResponse) = {
      val finalCall = finalCallForFqn(fullyQualifiedName).
        getOrElse(throw new IllegalArgumentException(s"$fullyQualifiedName is not a final call"))

      val callInputs = finalCall.createCallInputs(workflow, metadata)
      BackendCallJobDescriptor(workflow, backendCallKey, callInputs, None)
    }
  }
}
